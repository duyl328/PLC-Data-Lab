<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½PLCæ•°æ®æ ¼å¼è½¬æ¢ä¸è°ƒè¯•å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        /* è¯­è¨€å’ŒGithubæŒ‰é’®æ ·å¼ */
        .header-buttons {
            position: absolute;
            top: 20px;
            right: 30px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .lang-btn, .github-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(10px);
        }

        .lang-btn:hover, .github-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .lang-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .github-btn {
            background: rgba(36, 41, 46, 0.8);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .github-btn:hover {
            background: rgba(36, 41, 46, 0.9);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }
        
        .input-section, .control-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border: 1px solid #e0e6ed;
        }
        
        .section-title {
            font-size: 1.4em;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #34495e;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.3);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
        }
        
        .btn-smart {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        
        /* æ™ºèƒ½æ£€æµ‹é¢æ¿æ ·å¼ - ç´§å‡‘ç‰ˆ */
        .smart-detection {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 2px solid #17a2b8;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }
        
        .smart-detection::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, #17a2b8, #138496);
        }
        
        .detection-header {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .detection-results {
            display: grid;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .detection-results::-webkit-scrollbar {
            width: 6px;
        }
        
        .detection-results::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .detection-results::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }
        
        .detection-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }
        
        .detection-category {
            font-weight: 600;
            color: #495057;
            margin-top: 8px;
            margin-bottom: 4px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .confidence-high {
            border-left: 3px solid #28a745;
            background: linear-gradient(90deg, rgba(40, 167, 69, 0.08), white);
        }
        
        .confidence-medium {
            border-left: 3px solid #ffc107;
            background: linear-gradient(90deg, rgba(255, 193, 7, 0.08), white);
        }
        
        .confidence-low {
            border-left: 3px solid #dc3545;
            background: linear-gradient(90deg, rgba(220, 53, 69, 0.08), white);
        }
        
        .confidence-badge {
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            color: white;
        }
        
        .badge-high {
            background: #28a745;
        }
        
        .badge-medium {
            background: #ffc107;
        }
        
        .badge-low {
            background: #dc3545;
        }
        
        .recommendation-panel {
            background: linear-gradient(135deg, #e8f5e8, #f0f8f0);
            border: 2px solid #28a745;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .recommendation-header {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            color: #155724;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .recommended-item {
            background: white;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 10px;
            margin: 8px 0;
            position: relative;
            font-size: 13px;
        }
        
        .recommended-badge {
            position: absolute;
            top: -6px;
            right: 10px;
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }
        
        .results-section {
            grid-column: 1 / -1;
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border: 1px solid #e0e6ed;
            margin-top: 20px;
        }
        
        .results-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ecf0f1;
        }
        
        .tab-btn {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            color: #7f8c8d;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .tab-btn.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }
        
        .tab-btn.smart {
            color: #e74c3c;
        }
        
        .tab-btn.smart.active {
            border-bottom-color: #e74c3c;
        }
        
        /* Tabè®¡æ•°å™¨æ ·å¼ */
        .tab-counter {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            min-width: 18px;
            height: 18px;
            font-size: 11px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .result-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .result-item:hover {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateY(-2px);
        }
        
        .result-item.recommended {
            border: 2px solid #28a745;
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), #f8f9fa);
        }
        
        .result-item.failed {
            opacity: 0.5;
            border-color: #dc3545;
            background: linear-gradient(135deg, rgba(220, 53, 69, 0.1), #f8f9fa);
        }
        
        .result-header {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-header-sub{
            /*max-width: 210px;*/
        }
        
        .result-value {
            font-family: 'Consolas', 'Monaco', monospace;
            background: white;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            word-break: break-all;
            font-size: 13px;
        }
        
        .copy-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .copy-btn:hover {
            background: #138496;
        }
        
        .details-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 4px;
        }
        
        .details-btn:hover {
            background: #1e7e34;
        }
        
        .success-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .success-indicator.success {
            background: #28a745;
        }
        
        .success-indicator.warning {
            background: #ffc107;
        }
        
        .success-indicator.error {
            background: #dc3545;
        }
        
        /* è¯¦æƒ…æ¨¡æ€æ¡†æ ·å¼ - å¢å¤§å°ºå¯¸ */
        .details-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 0;
            border-radius: 15px;
            width: 95%;
            max-width: 1200px;
            max-height: 95vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .modal-header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 20px 30px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            font-size: 1.5em;
            font-weight: 600;
            margin: 0;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .close-btn:hover {
            transform: rotate(90deg);
            opacity: 0.7;
        }
        
        .modal-body {
            padding: 25px 30px;
            max-height: 75vh;
            overflow-y: auto;
        }
        
        .modal-body::-webkit-scrollbar {
            width: 8px;
        }
        
        .modal-body::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .modal-body::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        /* è¯¦æƒ…å†…å®¹æ ·å¼ */
        .detail-section {
            margin-bottom: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #3498db;
        }
        
        .detail-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .byteorder-test {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .byteorder-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        
        .byteorder-item:last-child {
            border-bottom: none;
        }
        
        .byteorder-label {
            font-weight: 600;
            color: #495057;
        }
        
        .byteorder-value {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #f1f3f4;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .byteorder-status {
            font-size: 18px;
        }
        
        .principle-box {
            background: #e8f5e8;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .principle-item {
            margin: 8px 0;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }
        
        .principle-item strong {
            min-width: 100px;
            color: #155724;
        }
        
        .memory-layout {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .memory-step {
            margin: 5px 0;
            padding: 5px 0;
        }
        
        .memory-bytes {
            background: #fff;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            display: inline-block;
            margin: 0 5px;
            font-weight: 600;
        }
        
        /* åŸå§‹æ•°æ®å±•ç¤ºæ ·å¼ */
        .process-step {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .process-step:hover {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(5px);
        }
        
        .step-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .step-content {
            font-family: 'Consolas', 'Monaco', monospace;
            background: white;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            word-break: break-all;
            color: #495057;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .error {
            color: #e74c3c;
            background: #fadbd8;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .statistics-panel {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat-item {
            text-align: center;
            background: white;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #ffecb5;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: #856404;
        }
        
        .stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        
        /* è‡ªåŠ¨é€‰æ‹©æç¤º */
        .auto-select-notice {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 10px 0;
            font-size: 12px;
            color: #0c5460;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .auto-select-notice::before {
            content: 'â„¹ï¸';
        }
        
        /* ç¦ç”¨bodyæ»šåŠ¨ */
        .modal-open {
            overflow: hidden;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 20px;
            }
            
            .container {
                margin: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .result-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-content {
                width: 98%;
                margin: 1% auto;
            }
            
            .modal-header {
                padding: 15px 20px;
            }
            
            .modal-body {
                padding: 20px;
            }

            .header-buttons {
                position: static;
                justify-content: center;
                margin-top: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <!-- è¯­è¨€åˆ‡æ¢å’ŒGithubæŒ‰é’® -->
            <div class="header-buttons">
                <button class="lang-btn active" onclick="switchLanguage('zh')" data-lang="zh">
                    ğŸ‡¨ğŸ‡³ ä¸­æ–‡
                </button>
                <button class="lang-btn" onclick="switchLanguage('en')" data-lang="en">
                    ğŸ‡ºğŸ‡¸ English
                </button>
                <a href="https://github.com/duyl328/PLC-Data-Lab" target="_blank" class="github-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                    </svg>
                    <span data-i18n="github">Github</span>
                </a>
            </div>

            <h1 data-i18n="title">æ™ºèƒ½PLCæ•°æ®æ ¼å¼è½¬æ¢ä¸è°ƒè¯•å·¥å…·</h1>
            <p data-i18n="subtitle">æ•°æ®æ ¼å¼æ£€æµ‹ã€è½¬æ¢ä¸æ™ºèƒ½æ¨èç³»ç»Ÿ</p>
        </div>
        
        <div class="main-content">
            <!-- æ•°æ®è¾“å…¥åŒº -->
            <div class="input-section">
                <div class="section-title">
                    ğŸ“¥ <span data-i18n="data_input">æ•°æ®è¾“å…¥åŒº</span>
                </div>
                
                <div class="form-group">
                    <label data-i18n="input_format">è¾“å…¥æ ¼å¼é€‰æ‹©ï¼š</label>
                    <select id="inputFormat">
                        <option value="byte" data-i18n="byte_format">byte[] (0-255)</option>
                        <option value="ushort" selected data-i18n="ushort_format">ushort[] (0-65535)</option>
                        <option value="short" data-i18n="short_format">short[] (-32768 to 32767)</option>
                        <option value="int" data-i18n="int_format">int[] (-2147483648 to 2147483647)</option>
                        <option value="uint" data-i18n="uint_format">uint[] (0 to 4294967295)</option>
                        <option value="hex" data-i18n="hex_format">Hex å­—ç¬¦ä¸²</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label data-i18n="raw_data_input">åŸå§‹æ•°æ®è¾“å…¥ï¼š</label>
                    <textarea id="rawData" data-i18n-placeholder="raw_data_placeholder"></textarea>
                </div>
                
                <div class="form-group">
                    <button class="btn btn-smart" onclick="intelligentAnalysis()">ğŸ§  <span data-i18n="intelligent_analysis">æ™ºèƒ½åˆ†æ</span></button>
                    <button class="btn" onclick="parseInput()">ğŸ“Š <span data-i18n="parse_data">è§£ææ•°æ®</span></button>
                    <button class="btn btn-secondary" onclick="clearInput()">ğŸ—‘ï¸ <span data-i18n="clear">æ¸…ç©º</span></button>
                </div>
                
                <div id="inputValidation"></div>
                
                <!-- æ™ºèƒ½æ£€æµ‹ç»“æœé¢æ¿ - ç§»åˆ°è¾“å…¥åŒºä¸‹æ–¹ -->
                <div id="smartDetection" class="smart-detection" style="display: none;">
                    <div class="detection-header">
                        ğŸ” <span data-i18n="smart_detection_result">æ™ºèƒ½æ£€æµ‹ç»“æœ</span>
                    </div>
                    <div id="detectionResults" class="detection-results"></div>
                </div>
            </div>
            
            <!-- æ§åˆ¶é€‰é¡¹åŒº -->
            <div class="control-section">
                <div class="section-title">
                    âš™ï¸ <span data-i18n="conversion_control">è½¬æ¢æ§åˆ¶</span>
                </div>
                
                <!-- è‡ªåŠ¨é€‰æ‹©æç¤º -->
                <div id="autoSelectNotice" class="auto-select-notice" style="display: none;">
                    <span data-i18n="auto_select_notice">å·²æ ¹æ®æ™ºèƒ½æ£€æµ‹ç»“æœè‡ªåŠ¨é€‰æ‹©æœ€ä¼˜é…ç½®</span>
                </div>
                
                <div class="form-group">
                    <label data-i18n="target_data_type">ç›®æ ‡æ•°æ®ç±»å‹ï¼š</label>
                    <select id="targetType" onchange="filterResults()">
                        <option value="all" data-i18n="show_all_types">ğŸ”„ æ˜¾ç¤ºæ‰€æœ‰ç±»å‹</option>
                        <option value="bool" data-i18n="bool_type">bool (å¸ƒå°”)</option>
                        <option value="byte" data-i18n="byte_type">byte (æ— ç¬¦å·8ä½)</option>
                        <option value="sbyte" data-i18n="sbyte_type">sbyte (æœ‰ç¬¦å·8ä½)</option>
                        <option value="short" data-i18n="short_type">short (æœ‰ç¬¦å·16ä½)</option>
                        <option value="ushort" data-i18n="ushort_type">ushort (æ— ç¬¦å·16ä½)</option>
                        <option value="int" data-i18n="int_type">int (æœ‰ç¬¦å·32ä½)</option>
                        <option value="uint" data-i18n="uint_type">uint (æ— ç¬¦å·32ä½)</option>
                        <option value="long" data-i18n="long_type">long (æœ‰ç¬¦å·64ä½)</option>
                        <option value="ulong" data-i18n="ulong_type">ulong (æ— ç¬¦å·64ä½)</option>
                        <option value="float" data-i18n="float_type">float (32ä½æµ®ç‚¹)</option>
                        <option value="double" data-i18n="double_type">double (64ä½æµ®ç‚¹)</option>
                        <option value="ascii" data-i18n="ascii_type">ASCII å­—ç¬¦ä¸²</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label data-i18n="byte_order_selection">å­—èŠ‚åºé€‰æ‹©ï¼š</label>
                    <select id="byteOrder" onchange="filterResults()">
                        <option value="all" data-i18n="show_all_byte_order">ğŸ”„ æ˜¾ç¤ºæ‰€æœ‰å­—èŠ‚åº</option>
                        <option value="ABCD" data-i18n="abcd_big_endian">ABCD (å¤§ç«¯åº)</option>
                        <option value="DCBA" data-i18n="dcba_little_endian">DCBA (å°ç«¯åº)</option>
                        <option value="CDAB" data-i18n="cdab_siemens">CDAB (è¥¿é—¨å­å¸¸è§)</option>
                        <option value="BADC" data-i18n="badc_omron">BADC (æ¬§å§†é¾™å¸¸è§)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label data-i18n="encoding_format">ç¼–ç æ ¼å¼ï¼š</label>
                    <select id="encoding" onchange="filterResults()">
                        <option value="all" data-i18n="show_all_encoding">ğŸ”„ æ˜¾ç¤ºæ‰€æœ‰ç¼–ç </option>
                        <option value="DEC" data-i18n="dec_encoding">DEC (åè¿›åˆ¶ç¼–ç )</option>
                        <option value="BCD" data-i18n="bcd_encoding">BCD (äºŒè¿›åˆ¶ç¼–ç åè¿›åˆ¶)</option>
                        <option value="HEX" data-i18n="hex_encoding">HEX (åå…­è¿›åˆ¶ç¼–ç )</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <button class="btn btn-success" onclick="convertData()">ğŸš€ <span data-i18n="convert">è½¬æ¢</span></button>
                </div>
                
                <!-- æ¨èé…ç½®é¢æ¿ -->
                <div id="recommendationPanel" class="recommendation-panel" style="display: none;">
                    <div class="recommendation-header">
                        â­ <span data-i18n="smart_recommendation">æ™ºèƒ½æ¨èé…ç½®</span>
                    </div>
                    <div id="recommendedConfigs"></div>
                    <button class="btn btn-success" onclick="applyRecommendation()">âœ… <span data-i18n="apply_recommendation">åº”ç”¨æ¨èé…ç½®</span></button>
                </div>
            </div>
        </div>
        
        <!-- ç»“æœå±•ç¤ºåŒº -->
        <div class="results-section" id="resultsSection" style="display: none;">
            <div class="section-title">
                ğŸ“Š <span data-i18n="conversion_results">è½¬æ¢ç»“æœ</span>
            </div>
            
            <!-- ç»Ÿè®¡ä¿¡æ¯é¢æ¿ -->
            <div id="statisticsPanel" class="statistics-panel" style="display: none;">
                <h4>ğŸ“ˆ <span data-i18n="conversion_statistics">è½¬æ¢ç»Ÿè®¡</span></h4>
                <div id="statisticsGrid" class="stats-grid"></div>
            </div>
            
            <div class="results-tabs">
                <button class="tab-btn smart active" onclick="switchTab('smart-results')">ğŸ§  <span data-i18n="intelligent_recommendation">æ™ºèƒ½æ¨è</span></button>
                <button class="tab-btn" onclick="switchTab('all-results')">
                    <span data-i18n="conversion_results_tab">è½¬æ¢ç»“æœ</span>
                    <span class="tab-counter" id="allResultsCounter" style="display: none;">0</span>
                </button>
                <button class="tab-btn" onclick="switchTab('raw-data')"><span data-i18n="raw_data">åŸå§‹æ•°æ®</span></button>
            </div>
            
            <div id="smart-results" class="tab-content active">
                <div id="smartResultsGrid" class="result-grid"></div>
            </div>
            
            <div id="all-results" class="tab-content">
                <div id="allResultsGrid" class="result-grid"></div>
            </div>
            
            <div id="raw-data" class="tab-content">
                <div id="rawDataDisplay"></div>
            </div>
        </div>
    </div>

    <!-- è¯¦æƒ…æ¨¡æ€æ¡† -->
    <div id="detailsModal" class="details-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle" data-i18n="conversion_details">è½¬æ¢è¯¦æƒ…</h2>
                <button class="close-btn" onclick="closeDetailsModal()">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- è¯¦æƒ…å†…å®¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <script>
        // å›½é™…åŒ–è¯­è¨€åŒ…
        const i18n = {
            zh: {
                title: 'æ™ºèƒ½PLCæ•°æ®æ ¼å¼è½¬æ¢ä¸è°ƒè¯•å·¥å…·',
                subtitle: 'æ•°æ®æ ¼å¼æ£€æµ‹ã€è½¬æ¢ä¸æ™ºèƒ½æ¨èç³»ç»Ÿ',
                github: 'Github',
                data_input: 'æ•°æ®è¾“å…¥åŒº',
                input_format: 'è¾“å…¥æ ¼å¼é€‰æ‹©ï¼š',
                byte_format: 'byte[] (0-255)',
                ushort_format: 'ushort[] (0-65535)',
                short_format: 'short[] (-32768 to 32767)',
                int_format: 'int[] (-2147483648 to 2147483647)',
                uint_format: 'uint[] (0 to 4294967295)',
                hex_format: 'Hex å­—ç¬¦ä¸²',
                raw_data_input: 'åŸå§‹æ•°æ®è¾“å…¥ï¼š',
                raw_data_placeholder: 'ç¤ºä¾‹ï¼š[13312,0,16128,0,13312,0,8704,0,5888,0]\næˆ–è€…ï¼š0x3400,0x0000,0x3F00,0x0000\næ”¯æŒé€—å·ã€ç©ºæ ¼ã€æ¢è¡Œåˆ†éš”',
                intelligent_analysis: 'æ™ºèƒ½åˆ†æ',
                parse_data: 'è§£ææ•°æ®',
                clear: 'æ¸…ç©º',
                smart_detection_result: 'æ™ºèƒ½æ£€æµ‹ç»“æœ',
                conversion_control: 'è½¬æ¢æ§åˆ¶',
                auto_select_notice: 'å·²æ ¹æ®æ™ºèƒ½æ£€æµ‹ç»“æœè‡ªåŠ¨é€‰æ‹©æœ€ä¼˜é…ç½®',
                target_data_type: 'ç›®æ ‡æ•°æ®ç±»å‹ï¼š',
                show_all_types: 'ğŸ”„ æ˜¾ç¤ºæ‰€æœ‰ç±»å‹',
                bool_type: 'bool (å¸ƒå°”)',
                byte_type: 'byte (æ— ç¬¦å·8ä½)',
                sbyte_type: 'sbyte (æœ‰ç¬¦å·8ä½)',
                short_type: 'short (æœ‰ç¬¦å·16ä½)',
                ushort_type: 'ushort (æ— ç¬¦å·16ä½)',
                int_type: 'int (æœ‰ç¬¦å·32ä½)',
                uint_type: 'uint (æ— ç¬¦å·32ä½)',
                long_type: 'long (æœ‰ç¬¦å·64ä½)',
                ulong_type: 'ulong (æ— ç¬¦å·64ä½)',
                float_type: 'float (32ä½æµ®ç‚¹)',
                double_type: 'double (64ä½æµ®ç‚¹)',
                ascii_type: 'ASCII å­—ç¬¦ä¸²',
                byte_order_selection: 'å­—èŠ‚åºé€‰æ‹©ï¼š',
                show_all_byte_order: 'ğŸ”„ æ˜¾ç¤ºæ‰€æœ‰å­—èŠ‚åº',
                abcd_big_endian: 'ABCD (å¤§ç«¯åº)',
                dcba_little_endian: 'DCBA (å°ç«¯åº)',
                cdab_siemens: 'CDAB (è¥¿é—¨å­å¸¸è§)',
                badc_omron: 'BADC (æ¬§å§†é¾™å¸¸è§)',
                encoding_format: 'ç¼–ç æ ¼å¼ï¼š',
                show_all_encoding: 'ğŸ”„ æ˜¾ç¤ºæ‰€æœ‰ç¼–ç ',
                dec_encoding: 'DEC (åè¿›åˆ¶ç¼–ç )',
                bcd_encoding: 'BCD (äºŒè¿›åˆ¶ç¼–ç åè¿›åˆ¶)',
                hex_encoding: 'HEX (åå…­è¿›åˆ¶ç¼–ç )',
                convert: 'è½¬æ¢',
                smart_recommendation: 'æ™ºèƒ½æ¨èé…ç½®',
                apply_recommendation: 'åº”ç”¨æ¨èé…ç½®',
                conversion_results: 'è½¬æ¢ç»“æœ',
                conversion_statistics: 'è½¬æ¢ç»Ÿè®¡',
                intelligent_recommendation: 'æ™ºèƒ½æ¨è',
                conversion_results_tab: 'è½¬æ¢ç»“æœ',
                raw_data: 'åŸå§‹æ•°æ®',
                conversion_details: 'è½¬æ¢è¯¦æƒ…',
                // ç»Ÿè®¡ç›¸å…³
                total_conversions: 'æ€»è½¬æ¢æ•°',
                successful_conversions: 'æˆåŠŸè½¬æ¢',
                failed_conversions: 'è½¬æ¢å¤±è´¥',
                smart_recommendations: 'æ™ºèƒ½æ¨è',
                success_rate: 'æˆåŠŸç‡',
                recommendation_rate: 'æ¨èç‡',
                // æ™ºèƒ½æ£€æµ‹ç›¸å…³
                encoding_format_detection: 'ç¼–ç æ ¼å¼',
                byte_order_detection: 'å­—èŠ‚åº',
                strongly_recommended: 'å¼ºçƒˆæ¨è',
                recommended: 'æ¨è',
                // é”™è¯¯æ¶ˆæ¯
                no_data_input: 'è¯·è¾“å…¥æ•°æ®',
                invalid_hex_format: 'æ— æ•ˆçš„åå…­è¿›åˆ¶æ ¼å¼',
                invalid_number: 'æ— æ•ˆçš„æ•°å€¼',
                data_parsed_successfully: 'æˆåŠŸè§£æ',
                items: 'ä¸ªæ•°æ®é¡¹',
                value_out_of_range: 'æ•°å€¼è¶…å‡ºèŒƒå›´',
                no_data_to_convert: 'è¯·å…ˆè¾“å…¥å¹¶è§£ææ•°æ®',
                no_recommendations: 'æ²¡æœ‰æ¨èé…ç½®å¯åº”ç”¨',
                // æ™ºèƒ½åˆ†æç›¸å…³
                bcd_format_match: 'å­—èŠ‚ç¬¦åˆBCDæ ¼å¼',
                non_bcd_bytes: 'å­˜åœ¨éBCDæ ¼å¼å­—èŠ‚',
                printable_characters: 'å­—èŠ‚ä¸ºå¯æ‰“å°å­—ç¬¦',
                ascii_characters: 'å­—èŠ‚ä¸ºASCIIå­—ç¬¦',
                low_ascii_ratio: 'ASCIIå­—ç¬¦æ¯”ä¾‹è¾ƒä½',
                decimal_always_valid: 'åè¿›åˆ¶ç¼–ç å§‹ç»ˆæœ‰æ•ˆ',
                reasonable_floats: 'ä¸ªæµ®ç‚¹æ•°è½¬æ¢åˆç†',
                valid_floats: 'ä¸ªæµ®ç‚¹æ•°è½¬æ¢æœ‰æ•ˆ',
                poor_float_conversion: 'æµ®ç‚¹æ•°è½¬æ¢æ•ˆæœä¸ä½³',
                insufficient_data_length: 'æ•°æ®é•¿åº¦ä¸è¶³ä»¥è¿›è¡Œæµ®ç‚¹æ•°åˆ†æ',
                reasonable_16bit_values: 'ä¸ª16ä½å€¼åˆç†',
                reasonable_byte_values: 'ä¸ªå­—èŠ‚å€¼åˆç†',
                high_confidence_ascii: 'ASCIIå­—ç¬¦æ£€æµ‹ç½®ä¿¡åº¦é«˜ï¼Œæ¨èå­—ç¬¦ä¸²è§£æ',
                high_confidence_bcd: 'BCDç¼–ç æ£€æµ‹ç½®ä¿¡åº¦é«˜ï¼Œæ¨èæ— ç¬¦å·æ•´æ•°',
                best_byteorder_float: 'å­—èŠ‚åºæµ®ç‚¹æ•°è½¬æ¢æ•ˆæœæœ€ä½³',
                good_16bit_parsing: '16ä½æ— ç¬¦å·æ•´æ•°è§£ææ•ˆæœè¾ƒå¥½',
                no_high_confidence: 'æœªå‘ç°é«˜ç½®ä¿¡åº¦çš„æ ¼å¼ç‰¹å¾',
                // è¯¦æƒ…é¡µé¢ç›¸å…³
                conversion_result_title: 'è½¬æ¢ç»“æœ',
                current_config: 'å½“å‰é…ç½®ï¼š',
                data_type: 'æ•°æ®ç±»å‹',
                byte_order: 'å­—èŠ‚åº',
                encoding_format_detail: 'ç¼–ç æ ¼å¼',
                conversion_result: 'è½¬æ¢ç»“æœ',
                all_byte_order_tests: 'æ‰€æœ‰å­—èŠ‚åºæ ¼å¼æµ‹è¯•ç»“æœ',
                format: 'æ ¼å¼',
                conversion_failed: 'è½¬æ¢å¤±è´¥',
                conversion_principle: 'è½¬æ¢åŸç†è¯´æ˜',
                problem_analysis: 'é—®é¢˜åˆ†æï¼š',
                data_analysis: 'æ•°æ®åˆ†æï¼š',
                byte_order_explanation: 'å­—èŠ‚åºè¯´æ˜ï¼š',
                big_endian_desc: 'å¤§ç«¯åºï¼šé«˜å­—èŠ‚åœ¨å‰ï¼Œä½å­—èŠ‚åœ¨åï¼Œå¦‚ 0x12345678 å­˜å‚¨ä¸º [12][34][56][78]',
                little_endian_desc: 'å°ç«¯åºï¼šä½å­—èŠ‚åœ¨å‰ï¼Œé«˜å­—èŠ‚åœ¨åï¼Œå¦‚ 0x12345678 å­˜å‚¨ä¸º [78][56][34][12]',
                middle_endian_ab_desc: 'ä¸­ç«¯åºï¼šå­—å¯¹äº¤æ¢çš„å¤§ç«¯åºï¼Œè¥¿é—¨å­PLCå¸¸è§',
                middle_endian_dc_desc: 'ä¸­ç«¯åºï¼šå­—å¯¹äº¤æ¢çš„å°ç«¯åºï¼Œæ¬§å§†é¾™PLCå¸¸è§',
                memory_layout_analysis: 'å†…å­˜å¸ƒå±€åˆ†æ',
                original_data: 'åŸå§‹æ•°æ®',
                byte_representation: 'å­—èŠ‚è¡¨ç¤º',
                float_conversion_example: 'æµ®ç‚¹æ•°è½¬æ¢ç¤ºä¾‹',
                order: 'é¡ºåº',
                // åŸå§‹æ•°æ®æ˜¾ç¤º
                input_data: 'è¾“å…¥æ•°æ®',
                convert_to_byte_array: 'è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„',
                hex_representation: 'åå…­è¿›åˆ¶è¡¨ç¤º',
                binary_representation: 'äºŒè¿›åˆ¶è¡¨ç¤º',
                // æ•°æ®åˆ†ææ–‡æœ¬
                ushort_to_int_analysis: 'æ¯2ä¸ª16ä½ushortå€¼è¢«ç»„åˆæˆ1ä¸ª32ä½intå€¼ï¼Œè¿™å¯èƒ½æ˜¯å› ä¸ºåŸå§‹æ•°æ®æ˜¯32ä½æ•´æ•°è¢«æ‹†åˆ†è¯»å–é€ æˆçš„ã€‚',
                int_to_ushort_analysis: 'æ¯ä¸ª32ä½intè¢«æ‹†åˆ†æˆ2ä¸ª16ä½ushortè¯»å–ï¼Œå¦‚æœè¯»å–ç»“æœä¸ç¬¦åˆé¢„æœŸï¼Œå¯èƒ½å­˜åœ¨å­—èŠ‚åºè½¬æ¢é—®é¢˜ã€‚',
                you_input: 'ä½ è¾“å…¥äº†',
                values: 'å€¼',
                convert_to: 'ï¼Œè½¬æ¢ä¸º',
                type: 'ç±»å‹ã€‚'
            },
            en: {
                title: 'Smart PLC Data Format Converter & Debugger',
                subtitle: 'Data Format Detection, Conversion & Smart Recommendation System',
                github: 'Github',
                data_input: 'Data Input',
                input_format: 'Input Format:',
                byte_format: 'byte[] (0-255)',
                ushort_format: 'ushort[] (0-65535)',
                short_format: 'short[] (-32768 to 32767)',
                int_format: 'int[] (-2147483648 to 2147483647)',
                uint_format: 'uint[] (0 to 4294967295)',
                hex_format: 'Hex String',
                raw_data_input: 'Raw Data Input:',
                raw_data_placeholder: 'Example: [13312,0,16128,0,13312,0,8704,0,5888,0]\nOr: 0x3400,0x0000,0x3F00,0x0000\nSupports comma, space, newline separation',
                intelligent_analysis: 'Smart Analysis',
                parse_data: 'Parse Data',
                clear: 'Clear',
                smart_detection_result: 'Smart Detection Result',
                conversion_control: 'Conversion Control',
                auto_select_notice: 'Optimal configuration automatically selected based on smart detection results',
                target_data_type: 'Target Data Type:',
                show_all_types: 'ğŸ”„ Show All Types',
                bool_type: 'bool (Boolean)',
                byte_type: 'byte (Unsigned 8-bit)',
                sbyte_type: 'sbyte (Signed 8-bit)',
                short_type: 'short (Signed 16-bit)',
                ushort_type: 'ushort (Unsigned 16-bit)',
                int_type: 'int (Signed 32-bit)',
                uint_type: 'uint (Unsigned 32-bit)',
                long_type: 'long (Signed 64-bit)',
                ulong_type: 'ulong (Unsigned 64-bit)',
                float_type: 'float (32-bit Float)',
                double_type: 'double (64-bit Double)',
                ascii_type: 'ASCII String',
                byte_order_selection: 'Byte Order:',
                show_all_byte_order: 'ğŸ”„ Show All Byte Orders',
                abcd_big_endian: 'ABCD (Big Endian)',
                dcba_little_endian: 'DCBA (Little Endian)',
                cdab_siemens: 'CDAB (Siemens Common)',
                badc_omron: 'BADC (Omron Common)',
                encoding_format: 'Encoding Format:',
                show_all_encoding: 'ğŸ”„ Show All Encodings',
                dec_encoding: 'DEC (Decimal Encoding)',
                bcd_encoding: 'BCD (Binary Coded Decimal)',
                hex_encoding: 'HEX (Hexadecimal Encoding)',
                convert: 'Convert',
                smart_recommendation: 'Smart Recommendations',
                apply_recommendation: 'Apply Recommendation',
                conversion_results: 'Conversion Results',
                conversion_statistics: 'Conversion Statistics',
                intelligent_recommendation: 'Smart Recommendations',
                conversion_results_tab: 'Results',
                raw_data: 'Raw Data',
                conversion_details: 'Conversion Details',
                // ç»Ÿè®¡ç›¸å…³
                total_conversions: 'Total',
                successful_conversions: 'Success',
                failed_conversions: 'Failed',
                smart_recommendations: 'Recommended',
                success_rate: 'Success Rate',
                recommendation_rate: 'Rec. Rate',
                // æ™ºèƒ½æ£€æµ‹ç›¸å…³
                encoding_format_detection: 'Encoding',
                byte_order_detection: 'Byte Order',
                strongly_recommended: 'Strongly Recommended',
                recommended: 'Recommended',
                // é”™è¯¯æ¶ˆæ¯
                no_data_input: 'Please input data',
                invalid_hex_format: 'Invalid hexadecimal format',
                invalid_number: 'Invalid number',
                data_parsed_successfully: 'Successfully parsed',
                items: 'data items',
                value_out_of_range: 'Value out of range',
                no_data_to_convert: 'Please input and parse data first',
                no_recommendations: 'No recommendation available',
                // æ™ºèƒ½åˆ†æç›¸å…³
                bcd_format_match: 'bytes match BCD format',
                non_bcd_bytes: 'Non-BCD format bytes exist',
                printable_characters: 'bytes are printable characters',
                ascii_characters: 'bytes are ASCII characters',
                low_ascii_ratio: 'Low ASCII character ratio',
                decimal_always_valid: 'Decimal encoding is always valid',
                reasonable_floats: 'float conversions are reasonable',
                valid_floats: 'float conversions are valid',
                poor_float_conversion: 'Poor float conversion performance',
                insufficient_data_length: 'Insufficient data length for float analysis',
                reasonable_16bit_values: '16-bit values are reasonable',
                reasonable_byte_values: 'byte values are reasonable',
                high_confidence_ascii: 'High confidence ASCII detection, recommend string parsing',
                high_confidence_bcd: 'High confidence BCD detection, recommend unsigned integer',
                best_byteorder_float: 'byte order has best float conversion',
                good_16bit_parsing: '16-bit unsigned integer parsing works well',
                no_high_confidence: 'No high-confidence format features found',
                // è¯¦æƒ…é¡µé¢ç›¸å…³
                conversion_result_title: 'Conversion Result',
                current_config: 'Current Configuration:',
                data_type: 'Data Type',
                byte_order: 'Byte Order',
                encoding_format_detail: 'Encoding',
                conversion_result: 'Result',
                all_byte_order_tests: 'All Byte Order Test Results',
                format: 'Format',
                conversion_failed: 'Conversion Failed',
                conversion_principle: 'Conversion Principles',
                problem_analysis: 'Analysis:',
                data_analysis: 'Data Analysis:',
                byte_order_explanation: 'Byte Order Explanation:',
                big_endian_desc: 'Big Endian: High byte first, e.g., 0x12345678 stored as [12][34][56][78]',
                little_endian_desc: 'Little Endian: Low byte first, e.g., 0x12345678 stored as [78][56][34][12]',
                middle_endian_ab_desc: 'Middle Endian: Word-swapped big endian, common in Siemens PLCs',
                middle_endian_dc_desc: 'Middle Endian: Word-swapped little endian, common in Omron PLCs',
                memory_layout_analysis: 'Memory Layout Analysis',
                original_data: 'Original Data',
                byte_representation: 'Byte Representation',
                float_conversion_example: 'Float Conversion Example',
                order: 'Order',
                // åŸå§‹æ•°æ®æ˜¾ç¤º
                input_data: 'Input Data',
                convert_to_byte_array: 'Convert to Byte Array',
                hex_representation: 'Hex Representation',
                binary_representation: 'Binary Representation',
                // æ•°æ®åˆ†ææ–‡æœ¬
                ushort_to_int_analysis: 'Every 2 16-bit ushort values are combined into one 32-bit int value, possibly due to 32-bit integers being split during reading.',
                int_to_ushort_analysis: 'Each 32-bit int is split into 2 16-bit ushorts. If results don\'t meet expectations, byte order issues may exist.',
                you_input: 'You input ',
                values: ' values: [',
                convert_to: '], converting to ',
                type: ' type.'
            }
        };

        // å½“å‰è¯­è¨€
        let currentLanguage = 'zh';

        // åˆ‡æ¢è¯­è¨€
        function switchLanguage(lang) {
            currentLanguage = lang;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-lang') === lang) {
                    btn.classList.add('active');
                }
            });
            
            // æ›´æ–°é¡µé¢è¯­è¨€å±æ€§
            document.documentElement.lang = lang === 'zh' ? 'zh-CN' : 'en';
            
            // æ›´æ–°é¡µé¢æ ‡é¢˜
            document.title = i18n[lang].title;
            
            // æ›´æ–°æ‰€æœ‰å›½é™…åŒ–æ–‡æœ¬
            updateI18nTexts();
            
            // ä¿å­˜è¯­è¨€è®¾ç½®
            try {
                localStorage.setItem('plc-tool-lang', lang);
            } catch (e) {
                // å¿½ç•¥localStorageé”™è¯¯
            }
            
            // å¦‚æœæœ‰æ£€æµ‹ç»“æœï¼Œé‡æ–°æ˜¾ç¤ºï¼ˆå› ä¸ºéœ€è¦æ›´æ–°è¯­è¨€ï¼‰
            if (Object.keys(smartAnalysisResults).length > 0) {
                displaySmartDetection();
                displayRecommendations();
            }
            
            // å¦‚æœæœ‰è½¬æ¢ç»“æœï¼Œé‡æ–°æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
            if (allResults.length > 0) {
                const statistics = calculateStatistics();
                displayStatistics(statistics);
            }
        }

        // æ›´æ–°å›½é™…åŒ–æ–‡æœ¬
        function updateI18nTexts() {
            const texts = i18n[currentLanguage];
            
            // æ›´æ–°æ‰€æœ‰å¸¦æœ‰ data-i18n å±æ€§çš„å…ƒç´ 
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (texts[key]) {
                    element.textContent = texts[key];
                }
            });
            
            // æ›´æ–°å¸¦æœ‰ data-i18n-placeholder å±æ€§çš„å…ƒç´ 
            document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
                const key = element.getAttribute('data-i18n-placeholder');
                if (texts[key]) {
                    element.placeholder = texts[key];
                }
            });
        }

        // è·å–å›½é™…åŒ–æ–‡æœ¬
        function t(key, ...args) {
            let text = i18n[currentLanguage][key] || key;
            
            // å¦‚æœæœ‰å‚æ•°ï¼Œè¿›è¡Œå­—ç¬¦ä¸²æ›¿æ¢
            if (args.length > 0) {
                args.forEach((arg, index) => {
                    text = text.replace(`{${index}}`, arg);
                });
            }
            
            return text;
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–è¯­è¨€
        document.addEventListener('DOMContentLoaded', function() {
            // å°è¯•ä»localStorageåŠ è½½è¯­è¨€è®¾ç½®
            let savedLang = 'zh';
            try {
                savedLang = localStorage.getItem('plc-tool-lang') || 'zh';
            } catch (e) {
                // å¿½ç•¥localStorageé”™è¯¯
            }
            
            switchLanguage(savedLang);
            
            // è®¾ç½®é»˜è®¤æ•°æ®
            document.getElementById('rawData').value = '[13312,0,16128,0,13312,0,8704,0,5888,0]';
        });

        // åŸæœ‰çš„æ‰€æœ‰JavaScriptä»£ç ä¿æŒä¸å˜ï¼Œåªéœ€è¦ä¿®æ”¹æ˜¾ç¤ºæ–‡æœ¬çš„éƒ¨åˆ†
        let currentData = [];
        let currentInputFormat = 'ushort';
        let allResults = [];
        let smartAnalysisResults = {};
        let recommendedConfigs = [];
        
        // æ™ºèƒ½åˆ†æå‡½æ•°
        function intelligentAnalysis() {
            if (!parseInput(false)) {
                return;
            }
            
            // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
            clearPreviousResults();
            
            // æ‰§è¡Œæ™ºèƒ½æ£€æµ‹
            smartAnalysisResults = performSmartDetection();
            
            // æ˜¾ç¤ºæ£€æµ‹ç»“æœ
            displaySmartDetection();
            
            // ç”Ÿæˆæ¨èé…ç½®
            generateRecommendations();
            
            // è‡ªåŠ¨åº”ç”¨æœ€ä½³é…ç½®
            autoApplyBestConfig();
            
            // è‡ªåŠ¨è½¬æ¢å¹¶æ˜¾ç¤ºç»“æœ
            convertData(true);
        }
        
        // è‡ªåŠ¨åº”ç”¨æœ€ä½³é…ç½®
        function autoApplyBestConfig() {
            let bestEncoding = null;
            let bestEncodingScore = 0;
            let bestByteOrder = null;
            let bestByteOrderScore = 0;
            let bestDataType = null;
            let autoSelected = false;
            
            // æ‰¾å‡ºæœ€ä½³ç¼–ç æ ¼å¼ï¼ˆåªé€‰æ‹©é«˜ç½®ä¿¡åº¦çš„ï¼‰
            for (let [format, result] of Object.entries(smartAnalysisResults.encoding)) {
                if (result.confidence === 'high' && result.score > bestEncodingScore) {
                    bestEncoding = format;
                    bestEncodingScore = result.score;
                }
            }
            
            // æ‰¾å‡ºæœ€ä½³å­—èŠ‚åºï¼ˆåªé€‰æ‹©é«˜ç½®ä¿¡åº¦çš„ï¼‰
            for (let [order, result] of Object.entries(smartAnalysisResults.byteOrder)) {
                if (result.confidence === 'high' && result.score > bestByteOrderScore) {
                    bestByteOrder = order;
                    bestByteOrderScore = result.score;
                }
            }
            
            // æ ¹æ®æ¨èé…ç½®ç¡®å®šæœ€ä½³æ•°æ®ç±»å‹
            if (recommendedConfigs.length > 0 && recommendedConfigs[0].confidence === 'high') {
                bestDataType = recommendedConfigs[0].dataType;
            }
            
            // åº”ç”¨é«˜ç½®ä¿¡åº¦çš„é…ç½®
            if (bestEncoding && bestEncodingScore > 80) {
                document.getElementById('encoding').value = bestEncoding;
                autoSelected = true;
            }
            
            if (bestByteOrder && bestByteOrderScore > 70) {
                document.getElementById('byteOrder').value = bestByteOrder;
                autoSelected = true;
            }
            
            if (bestDataType) {
                document.getElementById('targetType').value = bestDataType;
                autoSelected = true;
            }
            
            // æ˜¾ç¤ºè‡ªåŠ¨é€‰æ‹©æç¤º
            if (autoSelected) {
                document.getElementById('autoSelectNotice').style.display = 'flex';
                setTimeout(() => {
                    document.getElementById('autoSelectNotice').style.display = 'none';
                }, 5000);
            }
        }
        
        // æ‰§è¡Œæ™ºèƒ½æ£€æµ‹
        function performSmartDetection() {
            const bytes = convertToBytes(currentData, currentInputFormat);
            const analysis = {
                encoding: analyzeEncoding(bytes),
                byteOrder: analyzeByteOrder(bytes),
                dataType: analyzeDataType(bytes),
                patterns: analyzePatterns(bytes)
            };
            
            return analysis;
        }
        
        // åˆ†æç¼–ç æ ¼å¼
        function analyzeEncoding(bytes) {
            const results = {};
            
            // BCDæ£€æµ‹
            let bcdValid = true;
            let bcdScore = 0;
            for (let byte of bytes) {
                const high = (byte >> 4) & 0xF;
                const low = byte & 0xF;
                if (high <= 9 && low <= 9) {
                    bcdScore++;
                } else {
                    bcdValid = false;
                    break;
                }
            }
            
            if (bcdValid && bytes.length > 0) {
                results.BCD = {
                    confidence: bcdScore === bytes.length ? 'high' : 'medium',
                    score: (bcdScore / bytes.length) * 100,
                    reason: `${bcdScore}/${bytes.length} ${t('bcd_format_match')}`
                };
            } else {
                results.BCD = {
                    confidence: 'low',
                    score: 0,
                    reason: t('non_bcd_bytes')
                };
            }
            
            // ASCIIæ£€æµ‹
            let asciiCount = 0;
            let printableCount = 0;
            for (let byte of bytes) {
                if (byte >= 0 && byte <= 127) {
                    asciiCount++;
                    if (byte >= 32 && byte <= 126) {
                        printableCount++;
                    }
                }
            }
            
            const asciiRatio = asciiCount / bytes.length;
            const printableRatio = printableCount / bytes.length;
            
            if (printableRatio > 0.7) {
                results.ASCII = {
                    confidence: 'high',
                    score: printableRatio * 100,
                    reason: `${printableCount}/${bytes.length} ${t('printable_characters')}`
                };
            } else if (asciiRatio > 0.8) {
                results.ASCII = {
                    confidence: 'medium',
                    score: asciiRatio * 100,
                    reason: `${asciiCount}/${bytes.length} ${t('ascii_characters')}`
                };
            } else {
                results.ASCII = {
                    confidence: 'low',
                    score: asciiRatio * 100,
                    reason: t('low_ascii_ratio')
                };
            }
            
            // DECæ£€æµ‹ï¼ˆé»˜è®¤æ€»æ˜¯å¯èƒ½çš„ï¼‰
            results.DEC = {
                confidence: 'high',
                score: 100,
                reason: t('decimal_always_valid')
            };
            
            return results;
        }
        
        // åˆ†æå­—èŠ‚åº
        function analyzeByteOrder(bytes) {
            const results = {};
            const byteOrders = ['ABCD', 'DCBA', 'CDAB', 'BADC'];
            
            // å°è¯•å°†å­—èŠ‚è½¬æ¢ä¸ºæµ®ç‚¹æ•°ï¼Œçœ‹å“ªç§å­—èŠ‚åºäº§ç”Ÿæœ€åˆç†çš„ç»“æœ
            for (let byteOrder of byteOrders) {
                let validFloatCount = 0;
                let reasonableFloatCount = 0;
                let totalAttempts = 0;
                
                for (let i = 0; i < bytes.length - 3; i += 4) {
                    try {
                        const orderedBytes = applyByteOrder([bytes[i], bytes[i + 1], bytes[i + 2], bytes[i + 3]], byteOrder, 4);
                        const buffer = new ArrayBuffer(4);
                        const view = new DataView(buffer);
                        for (let j = 0; j < 4; j++) {
                            view.setUint8(j, orderedBytes[j]);
                        }
                        const floatValue = view.getFloat32(0, true);
                        totalAttempts++;
                        
                        if (isFinite(floatValue) && !isNaN(floatValue)) {
                            validFloatCount++;
                            // æ£€æŸ¥æ˜¯å¦ä¸ºåˆç†çš„æµ®ç‚¹æ•°ï¼ˆä¸æ˜¯æå¤§æˆ–æå°çš„æ•°ï¼‰
                            if (Math.abs(floatValue) > 0.0001 && Math.abs(floatValue) < 1000000) {
                                reasonableFloatCount++;
                            }
                        }
                    } catch (error) {
                        // å¿½ç•¥è½¬æ¢é”™è¯¯
                    }
                }
                
                let confidence = 'low';
                let score = 0;
                let reason = '';
                
                if (totalAttempts > 0) {
                    const validRatio = validFloatCount / totalAttempts;
                    const reasonableRatio = reasonableFloatCount / totalAttempts;
                    score = reasonableRatio * 100;
                    
                    if (reasonableRatio > 0.7) {
                        confidence = 'high';
                        reason = `${reasonableFloatCount}/${totalAttempts} ${t('reasonable_floats')}`;
                    } else if (validRatio > 0.5) {
                        confidence = 'medium';
                        reason = `${validFloatCount}/${totalAttempts} ${t('valid_floats')}`;
                    } else {
                        reason = t('poor_float_conversion');
                    }
                } else {
                    reason = t('insufficient_data_length');
                }
                
                results[byteOrder] = {
                    confidence: confidence,
                    score: score,
                    reason: reason
                };
            }
            
            return results;
        }
        
        // åˆ†ææ•°æ®ç±»å‹
        function analyzeDataType(bytes) {
            const results = {};
            
            // æ£€æŸ¥16ä½æ•´æ•°çš„åˆç†æ€§
            let reasonableShortCount = 0;
            let totalShorts = 0;
            for (let i = 0; i < bytes.length - 1; i += 2) {
                const value = bytes[i] | (bytes[i + 1] << 8);
                totalShorts++;
                // æ£€æŸ¥æ˜¯å¦ä¸ºåˆç†çš„16ä½æ•°å€¼èŒƒå›´
                if (value < 10000 && value > 0) {
                    reasonableShortCount++;
                }
            }
            
            if (totalShorts > 0) {
                const shortRatio = reasonableShortCount / totalShorts;
                results.short = {
                    confidence: shortRatio > 0.6 ? 'high' : shortRatio > 0.3 ? 'medium' : 'low',
                    score: shortRatio * 100,
                    reason: `${reasonableShortCount}/${totalShorts} ${t('reasonable_16bit_values')}`
                };
            }
            
            // æ£€æŸ¥å­—èŠ‚çº§æ•°æ®
            let reasonableByteCount = 0;
            for (let byte of bytes) {
                if (byte > 0 && byte < 250) {
                    reasonableByteCount++;
                }
            }
            
            const byteRatio = reasonableByteCount / bytes.length;
            results.byte = {
                confidence: byteRatio > 0.8 ? 'high' : byteRatio > 0.5 ? 'medium' : 'low',
                score: byteRatio * 100,
                reason: `${reasonableByteCount}/${bytes.length} ${t('reasonable_byte_values')}`
            };
            
            return results;
        }
        
        // åˆ†ææ•°æ®æ¨¡å¼
        function analyzePatterns(bytes) {
            const patterns = {};
            
            // æ£€æŸ¥é‡å¤æ¨¡å¼
            const counts = {};
            for (let byte of bytes) {
                counts[byte] = (counts[byte] || 0) + 1;
            }
            
            const uniqueValues = Object.keys(counts).length;
            const maxRepeats = Math.max(...Object.values(counts));
            
            patterns.repetition = {
                uniqueValues: uniqueValues,
                maxRepeats: maxRepeats,
                entropy: uniqueValues / bytes.length
            };
            
            // æ£€æŸ¥é›¶å€¼æ¨¡å¼
            const zeroCount = counts[0] || 0;
            patterns.zeros = {
                count: zeroCount,
                ratio: zeroCount / bytes.length
            };
            
            return patterns;
        }
        
        // æ˜¾ç¤ºæ™ºèƒ½æ£€æµ‹ç»“æœ - ç´§å‡‘ç‰ˆ
        function displaySmartDetection() {
            const panel = document.getElementById('smartDetection');
            const results = document.getElementById('detectionResults');
            
            let html = '';
            
            // ç¼–ç æ ¼å¼æ£€æµ‹ç»“æœ - åªæ˜¾ç¤ºé«˜ç½®ä¿¡åº¦çš„
            const highConfidenceEncodings = Object.entries(smartAnalysisResults.encoding)
                .filter(([_, result]) => result.confidence !== 'low')
                .sort((a, b) => b[1].score - a[1].score);
            
            if (highConfidenceEncodings.length > 0) {
                html += `<div class="detection-category">${t('encoding_format_detection')}</div>`;
                for (let [format, result] of highConfidenceEncodings.slice(0, 3)) {
                    const confidenceClass = `confidence-${result.confidence}`;
                    const badgeClass = `badge-${result.confidence}`;
                    
                    html += `
                        <div class="detection-item ${confidenceClass}">
                            <div>
                                <strong>${format}</strong> - ${result.reason}
                            </div>
                            <div>
                                <span class="confidence-badge ${badgeClass}">${Math.round(result.score)}%</span>
                            </div>
                        </div>
                    `;
                }
            }
            
            // å­—èŠ‚åºæ£€æµ‹ç»“æœ - åªæ˜¾ç¤ºé«˜ç½®ä¿¡åº¦çš„
            const highConfidenceByteOrders = Object.entries(smartAnalysisResults.byteOrder)
                .filter(([_, result]) => result.confidence !== 'low')
                .sort((a, b) => b[1].score - a[1].score);
                
            if (highConfidenceByteOrders.length > 0) {
                html += `<div class="detection-category">${t('byte_order_detection')}</div>`;
                for (let [order, result] of highConfidenceByteOrders.slice(0, 3)) {
                    const confidenceClass = `confidence-${result.confidence}`;
                    const badgeClass = `badge-${result.confidence}`;
                    
                    html += `
                        <div class="detection-item ${confidenceClass}">
                            <div>
                                <strong>${order}</strong> - ${result.reason}
                            </div>
                            <div>
                                <span class="confidence-badge ${badgeClass}">${Math.round(result.score)}%</span>
                            </div>
                        </div>
                    `;
                }
            }
            
            results.innerHTML = html || `<div class="detection-item">${t('no_high_confidence')}</div>`;
            panel.style.display = 'block';
        }
        
        // ç”Ÿæˆæ¨èé…ç½®
        function generateRecommendations() {
            recommendedConfigs = [];
            
            // æ‰¾å‡ºæœ€ä½³ç¼–ç æ ¼å¼
            let bestEncoding = 'DEC';
            let bestEncodingScore = 0;
            for (let [format, result] of Object.entries(smartAnalysisResults.encoding)) {
                if (result.score > bestEncodingScore && result.confidence !== 'low') {
                    bestEncoding = format;
                    bestEncodingScore = result.score;
                }
            }
            
            // æ‰¾å‡ºæœ€ä½³å­—èŠ‚åº
            let bestByteOrder = 'DCBA';
            let bestByteOrderScore = 0;
            for (let [order, result] of Object.entries(smartAnalysisResults.byteOrder)) {
                if (result.score > bestByteOrderScore) {
                    bestByteOrder = order;
                    bestByteOrderScore = result.score;
                }
            }
            
            // ç”Ÿæˆæ¨èé…ç½®
            if (smartAnalysisResults.encoding.ASCII.confidence === 'high') {
                recommendedConfigs.push({
                    encoding: 'DEC',
                    byteOrder: 'DCBA',
                    dataType: 'ascii',
                    reason: t('high_confidence_ascii'),
                    confidence: 'high'
                });
            }
            
            if (smartAnalysisResults.encoding.BCD.confidence === 'high') {
                recommendedConfigs.push({
                    encoding: 'BCD',
                    byteOrder: bestByteOrder,
                    dataType: 'uint',
                    reason: t('high_confidence_bcd'),
                    confidence: 'high'
                });
            }
            
            // æµ®ç‚¹æ•°æ¨è
            if (bestByteOrderScore > 50) {
                recommendedConfigs.push({
                    encoding: bestEncoding,
                    byteOrder: bestByteOrder,
                    dataType: 'float',
                    reason: `${bestByteOrder}${t('best_byteorder_float')}`,
                    confidence: bestByteOrderScore > 70 ? 'high' : 'medium'
                });
            }
            
            // æ•´æ•°æ¨è
            if (smartAnalysisResults.dataType && smartAnalysisResults.dataType.short && 
                smartAnalysisResults.dataType.short.confidence !== 'low') {
                recommendedConfigs.push({
                    encoding: bestEncoding,
                    byteOrder: bestByteOrder,
                    dataType: 'ushort',
                    reason: t('good_16bit_parsing'),
                    confidence: smartAnalysisResults.dataType.short.confidence
                });
            }
            
            // æ˜¾ç¤ºæ¨èé…ç½®
            displayRecommendations();
        }
        
        // æ˜¾ç¤ºæ¨èé…ç½®
        function displayRecommendations() {
            const panel = document.getElementById('recommendationPanel');
            const container = document.getElementById('recommendedConfigs');
            
            if (recommendedConfigs.length === 0) {
                panel.style.display = 'none';
                return;
            }
            
            let html = '';
            recommendedConfigs.forEach((config, index) => {
                const badgeText = config.confidence === 'high' ? t('strongly_recommended') : t('recommended');
                html += `
                    <div class="recommended-item" data-index="${index}">
                        <div class="recommended-badge">${badgeText}</div>
                        <div>
                            <strong>${config.dataType.toUpperCase()} - ${config.byteOrder} - ${config.encoding}</strong><br>
                            <small>${config.reason}</small>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            panel.style.display = 'block';
        }
        
        // åº”ç”¨æ¨èé…ç½®
        function applyRecommendation() {
            if (recommendedConfigs.length === 0) {
                alert(t('no_recommendations'));
                return;
            }
            
            // åº”ç”¨ç¬¬ä¸€ä¸ªï¼ˆæœ€ä½³ï¼‰æ¨èé…ç½®
            const config = recommendedConfigs[0];
            document.getElementById('targetType').value = config.dataType;
            document.getElementById('byteOrder').value = config.byteOrder;
            document.getElementById('encoding').value = config.encoding;
            
            // è‡ªåŠ¨è½¬æ¢
            convertData(true);
        }
        
        // è§£æè¾“å…¥æ•°æ®ï¼ˆå¢å¼ºç‰ˆï¼‰
        function parseInput(showMessage = true) {
            const rawDataElement = document.getElementById('rawData');
            const inputFormat = document.getElementById('inputFormat').value;
            const validation = document.getElementById('inputValidation');
            
            try {
                const inputText = rawDataElement.value.trim();
                if (!inputText) {
                    throw new Error(t('no_data_input'));
                }
                
                // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
                clearPreviousResults();
                
                let parsedData = [];
                currentInputFormat = inputFormat;
                
                if (inputFormat === 'hex') {
                    const hexPattern = /0x[0-9A-Fa-f]+|[0-9A-Fa-f]+/g;
                    const hexMatches = inputText.match(hexPattern);
                    if (!hexMatches) {
                        throw new Error(t('invalid_hex_format'));
                    }
                    parsedData = hexMatches.map(hex => {
                        const value = parseInt(hex.replace('0x', ''), 16);
                        return value;
                    });
                } else {
                    const cleanText = inputText.replace(/[\[\]]/g, '');
                    const values = cleanText.split(/[,\s\n]+/).filter(v => v.trim());
                    
                    parsedData = values.map(v => {
                        const num = v.includes('0x') ? parseInt(v, 16) : parseInt(v);
                        if (isNaN(num)) {
                            throw new Error(`${t('invalid_number')}: ${v}`);
                        }
                        return num;
                    });
                }
                
                validateDataRange(parsedData, inputFormat);
                currentData = parsedData;
                
                if (showMessage) {
                    validation.innerHTML = `<div class="success">âœ… ${t('data_parsed_successfully')} ${parsedData.length} ${t('items')}</div>`;
                }
                
                return true;
                
            } catch (error) {
                if (showMessage) {
                    validation.innerHTML = `<div class="error">âŒ ${error.message}</div>`;
                }
                currentData = [];
                return false;
            }
        }
        
        // éªŒè¯æ•°æ®èŒƒå›´
        function validateDataRange(data, format) {
            const ranges = {
                'byte': [0, 255],
                'sbyte': [-128, 127],
                'ushort': [0, 65535],
                'short': [-32768, 32767],
                'int': [-2147483648, 2147483647],
                'uint': [0, 4294967295],
                'hex': [0, 4294967295]
            };
            
            if (ranges[format]) {
                const [min, max] = ranges[format];
                for (let value of data) {
                    if (value < min || value > max) {
                        throw new Error(`${t('value_out_of_range')} ${value} ${format} [${min}, ${max}]`);
                    }
                }
            }
        }
        
        // è½¬æ¢æ•°æ®ï¼ˆå¢å¼ºç‰ˆï¼‰
        function convertData(isSmartMode = false) {
            if (currentData.length === 0) {
                alert(t('no_data_to_convert'));
                return;
            }
            
            const targetType = document.getElementById('targetType').value;
            const byteOrder = document.getElementById('byteOrder').value;
            const encoding = document.getElementById('encoding').value;
            
            document.getElementById('resultsSection').style.display = 'block';
            
            // ç”Ÿæˆæ‰€æœ‰ç»“æœ
            allResults = generateAllResults();
            
            // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
            const statistics = calculateStatistics();
            displayStatistics(statistics);
            
            // è‡ªåŠ¨æ»šåŠ¨åˆ°ç»“æœåŒºåŸŸå¹¶åˆ‡æ¢æ ‡ç­¾
            setTimeout(() => {
                const resultsSection = document.getElementById('resultsSection');
                resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                // åˆ‡æ¢åˆ°ç›¸åº”çš„æ ‡ç­¾
                if (!isSmartMode) {
                    switchTabProgrammatically('all-results');
                } else {
                    switchTabProgrammatically('smart-results');
                }
            }, 100);
            
            // æ˜¾ç¤ºç»“æœ
            if (isSmartMode) {
                displaySmartResults();
            } else {
                displayResults(allResults, targetType, byteOrder, encoding);
            }
            
            displayRawData();
        }
        
        // æ›´æ–°ç»“æœè®¡æ•°å™¨
        function updateResultCounter(results = null) {
            const counter = document.getElementById('allResultsCounter');
            
            if (results === null) {
                // å¦‚æœæ²¡æœ‰ä¼ å…¥ç»“æœï¼Œéšè—è®¡æ•°å™¨
                counter.style.display = 'none';
                return;
            }
            
            const validResults = results.filter(r => r.isValid).length;
            counter.textContent = validResults;
            counter.style.display = validResults > 0 ? 'flex' : 'none';
        }
        
        // ç”Ÿæˆæ‰€æœ‰è½¬æ¢ç»“æœï¼ˆå¢å¼ºç‰ˆï¼‰
        function generateAllResults() {
            const results = [];
            const byteOrders = ['ABCD', 'DCBA', 'CDAB', 'BADC'];
            const encodings = ['DEC', 'BCD', 'HEX'];
            const dataTypes = ['bool', 'byte', 'sbyte', 'short', 'ushort', 'int', 'uint', 'long', 'ulong', 'float', 'double', 'ascii'];
            
            const bytes = convertToBytes(currentData, currentInputFormat);
            
            for (let byteOrder of byteOrders) {
                for (let encoding of encodings) {
                    for (let dataType of dataTypes) {
                        try {
                            const result = convertWithParams(bytes, dataType, byteOrder, encoding);
                            if (result.success) {
                                // è®¡ç®—æ™ºèƒ½è¯„åˆ†
                                const smartScore = calculateSmartScore(result, dataType, byteOrder, encoding);
                                
                                results.push({
                                    inputFormat: currentInputFormat,
                                    dataType,
                                    byteOrder,
                                    encoding,
                                    result: result.data,
                                    displayValue: result.displayValue,
                                    isValid: result.isValid,
                                    smartScore: smartScore,
                                    isRecommended: smartScore > 70,
                                    originalBytes: bytes
                                });
                            }
                        } catch (error) {
                            // è®°å½•å¤±è´¥çš„è½¬æ¢
                            results.push({
                                inputFormat: currentInputFormat,
                                dataType,
                                byteOrder,
                                encoding,
                                result: null,
                                displayValue: t('conversion_failed'),
                                isValid: false,
                                smartScore: 0,
                                isRecommended: false,
                                error: error.message,
                                originalBytes: bytes
                            });
                        }
                    }
                }
            }
            
            return results;
        }
        
        // è®¡ç®—æ™ºèƒ½è¯„åˆ†
        function calculateSmartScore(result, dataType, byteOrder, encoding) {
            let score = 0;
            
            // åŸºç¡€æœ‰æ•ˆæ€§è¯„åˆ†
            if (result.isValid) {
                score += 30;
            }
            
            // æ ¹æ®æ™ºèƒ½åˆ†æç»“æœåŠ åˆ†
            if (smartAnalysisResults.encoding && smartAnalysisResults.encoding[encoding]) {
                const encodingAnalysis = smartAnalysisResults.encoding[encoding];
                if (encodingAnalysis.confidence === 'high') {
                    score += 25;
                } else if (encodingAnalysis.confidence === 'medium') {
                    score += 15;
                }
            }
            
            if (smartAnalysisResults.byteOrder && smartAnalysisResults.byteOrder[byteOrder]) {
                const byteOrderAnalysis = smartAnalysisResults.byteOrder[byteOrder];
                if (byteOrderAnalysis.confidence === 'high') {
                    score += 25;
                } else if (byteOrderAnalysis.confidence === 'medium') {
                    score += 15;
                }
            }
            
            // æ•°æ®ç±»å‹ç‰¹å®šè¯„åˆ†
            if (dataType === 'float' || dataType === 'double') {
                if (result.data && result.data.length > 0) {
                    const validNumbers = result.data.filter(v => isFinite(v) && !isNaN(v) && Math.abs(v) > 0.0001 && Math.abs(v) < 1000000).length;
                    score += (validNumbers / result.data.length) * 20;
                }
            }
            
            return Math.min(100, score);
        }
        
        // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        function calculateStatistics() {
            const stats = {
                total: allResults.length,
                successful: 0,
                failed: 0,
                recommended: 0,
                byEncoding: {},
                byByteOrder: {},
                byDataType: {}
            };
            
            for (let result of allResults) {
                if (result.isValid) {
                    stats.successful++;
                } else {
                    stats.failed++;
                }
                
                if (result.isRecommended) {
                    stats.recommended++;
                }
                
                // æŒ‰åˆ†ç±»ç»Ÿè®¡
                stats.byEncoding[result.encoding] = (stats.byEncoding[result.encoding] || 0) + 1;
                stats.byByteOrder[result.byteOrder] = (stats.byByteOrder[result.byteOrder] || 0) + 1;
                stats.byDataType[result.dataType] = (stats.byDataType[result.dataType] || 0) + 1;
            }
            
            return stats;
        }
        
        // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
        function displayStatistics(stats) {
            const panel = document.getElementById('statisticsPanel');
            const grid = document.getElementById('statisticsGrid');
            
            const successRate = ((stats.successful / stats.total) * 100).toFixed(1);
            const recommendRate = ((stats.recommended / stats.total) * 100).toFixed(1);
            
            grid.innerHTML = `
                <div class="stat-item">
                    <div class="stat-value">${stats.total}</div>
                    <div class="stat-label">${t('total_conversions')}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.successful}</div>
                    <div class="stat-label">${t('successful_conversions')}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.failed}</div>
                    <div class="stat-label">${t('failed_conversions')}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.recommended}</div>
                    <div class="stat-label">${t('smart_recommendations')}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${successRate}%</div>
                    <div class="stat-label">${t('success_rate')}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${recommendRate}%</div>
                    <div class="stat-label">${t('recommendation_rate')}</div>
                </div>
            `;
            
            panel.style.display = 'block';
        }
        
        // æ˜¾ç¤ºæ™ºèƒ½æ¨èç»“æœ
        function displaySmartResults() {
            const grid = document.getElementById('smartResultsGrid');
            
            // æŒ‰æ™ºèƒ½è¯„åˆ†æ’åº
            const sortedResults = [...allResults].sort((a, b) => b.smartScore - a.smartScore);
            
            // åªæ˜¾ç¤ºè¯„åˆ†è¾ƒé«˜çš„ç»“æœ
            const topResults = sortedResults.filter(r => r.smartScore > 30).slice(0, 20);
            
            grid.innerHTML = '';
            for (let result of topResults) {
                const element = createResultElement(result, true);
                grid.appendChild(element);
            }
            
            if (topResults.length === 0) {
                grid.innerHTML = '<div class="result-item">æ²¡æœ‰æ‰¾åˆ°é«˜ç½®ä¿¡åº¦çš„è½¬æ¢ç»“æœ</div>';
            }
        }
        
        // åˆ›å»ºç»“æœå…ƒç´ ï¼ˆå¢å¼ºç‰ˆï¼‰
        function createResultElement(result, showSmartInfo = false) {
            const div = document.createElement('div');
            div.className = 'result-item';
            
            if (result.isRecommended) {
                div.classList.add('recommended');
            }
            
            if (!result.isValid) {
                div.classList.add('failed');
            }
            
            let smartInfo = '';
            if (showSmartInfo && result.smartScore !== undefined) {
                const scoreClass = result.smartScore > 70 ? 'success' : result.smartScore > 40 ? 'warning' : 'error';
                smartInfo = `
                    <div class="success-indicator ${scoreClass}" title="æ™ºèƒ½è¯„åˆ†: ${result.smartScore}"></div>
                `;
            }
            
            let statusIcon = 'âœ…';
            if (!result.isValid) {
                statusIcon = 'âŒ';
            } else if (result.isRecommended) {
                statusIcon = 'â­';
            }
            
            const resultIndex = allResults.indexOf(result);
            
            div.innerHTML = `
                ${smartInfo}
                <div class="result-header">
                    <span class="result-header-sub">${statusIcon} ${result.inputFormat.toUpperCase()} â†’ ${result.dataType.toUpperCase()} - ${result.byteOrder} - ${result.encoding}</span>
                    <div>
                        <button class="copy-btn" data-copy-value="${result.displayValue.replace(/"/g, '&quot;')}" onclick="copyResultFromButton(this)" title="å¤åˆ¶ç»“æœ">ğŸ“‹</button>
                        <button class="details-btn" onclick="showConversionDetails(${resultIndex})" title="æŸ¥çœ‹è¯¦æƒ…">ğŸ”</button>
                        ${showSmartInfo ? `<span style="font-size: 12px; color: #6c757d;">${result.smartScore}åˆ†</span>` : ''}
                    </div>
                </div>
                <div class="result-value">${result.displayValue}</div>
            `;
            
            return div;
        }
        
        // ä»æŒ‰é’®å¤åˆ¶ç»“æœçš„æ–°æ–¹æ³•
        function copyResultFromButton(button) {
            const value = button.getAttribute('data-copy-value').replace(/&quot;/g, '"');
            copyResult(value);
        }
        
        // æ˜¾ç¤ºè½¬æ¢è¯¦æƒ…ï¼ˆå¢å¼ºç‰ˆï¼ŒåŒ…å«ç¦ç”¨bodyæ»šåŠ¨ï¼‰
        function showConversionDetails(resultIndex) {
            const result = allResults[resultIndex];
            if (!result) return;
            
            const modal = document.getElementById('detailsModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = `${result.inputFormat.toUpperCase()} â†’ ${result.dataType.toUpperCase()} ${t('conversion_details')}`;
            
            // ç”Ÿæˆè¯¦ç»†å†…å®¹
            const detailsHtml = generateConversionDetails(result);
            modalBody.innerHTML = detailsHtml;
            
            // ç¦ç”¨bodyæ»šåŠ¨
            document.body.classList.add('modal-open');
            
            modal.style.display = 'block';
        }
        
        // ç”Ÿæˆè½¬æ¢è¯¦æƒ…å†…å®¹
        function generateConversionDetails(result) {
            const bytes = result.originalBytes;
            const byteOrders = ['ABCD', 'DCBA', 'CDAB', 'BADC'];
            
            let html = `
                <div class="detail-section">
                    <div class="detail-title">ğŸ“¤ ${t('conversion_result_title')}</div>
                    <div class="byteorder-test">
                        <strong>${t('current_config')}</strong>
                        <div class="byteorder-item">
                            <span class="byteorder-label">${t('data_type')}</span>
                            <span class="byteorder-value">${result.dataType.toUpperCase()}</span>
                            <span class="byteorder-status">${result.isValid ? 'âœ…' : 'âŒ'}</span>
                        </div>
                        <div class="byteorder-item">
                            <span class="byteorder-label">${t('byte_order')}</span>
                            <span class="byteorder-value">${result.byteOrder}</span>
                            <span class="byteorder-status">ğŸ”„</span>
                        </div>
                        <div class="byteorder-item">
                            <span class="byteorder-label">${t('encoding_format_detail')}</span>
                            <span class="byteorder-value">${result.encoding}</span>
                            <span class="byteorder-status">ğŸ¯</span>
                        </div>
                        <div class="byteorder-item">
                            <span class="byteorder-label">${t('conversion_result')}</span>
                            <span class="byteorder-value" style="max-width: 300px; word-break: break-all;">${result.displayValue}</span>
                            <span class="byteorder-status">${result.isValid ? 'âœ…' : 'âŒ'}</span>
                        </div>
                    </div>
                </div>
            `;
            
            // æ˜¾ç¤ºæ‰€æœ‰å­—èŠ‚åºæµ‹è¯•ç»“æœ
            if (result.dataType !== 'ascii' && result.dataType !== 'bool' && result.dataType !== 'byte') {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">ğŸ§ª ${t('all_byte_order_tests')}</div>
                        <div class="byteorder-test">
                `;
                
                for (let byteOrder of byteOrders) {
                    try {
                        const testResult = convertWithParams(bytes, result.dataType, byteOrder, result.encoding);
                        const isSuccess = testResult.success && testResult.isValid;
                        const displayValue = testResult.success ? testResult.displayValue : t('conversion_failed');
                        
                        html += `
                            <div class="byteorder-item">
                                <span class="byteorder-label">${byteOrder}${t('format')}</span>
                                <span class="byteorder-value">[${displayValue}]</span>
                                <span class="byteorder-status">${isSuccess ? 'âœ…' : 'âŒ'}</span>
                            </div>
                        `;
                    } catch (error) {
                        html += `
                            <div class="byteorder-item">
                                <span class="byteorder-label">${byteOrder}${t('format')}</span>
                                <span class="byteorder-value">${t('conversion_failed')}</span>
                                <span class="byteorder-status">âŒ</span>
                            </div>
                        `;
                    }
                }
                
                html += '</div></div>';
            }
            
            // è½¬æ¢åŸç†è¯´æ˜
            html += `
                <div class="detail-section">
                    <div class="detail-title">ğŸ“š ${t('conversion_principle')}</div>
                    <div class="principle-box">
                        <div class="principle-item">
                            <strong>${t('problem_analysis')}</strong>
                            <span>${t('you_input')}${currentData.length}${t('values')}${currentData.slice(0, 10).join(', ')}${currentData.length > 10 ? '...' : ''}]${t('convert_to')}${result.dataType}${t('type')}</span>
                        </div>
            `;
            
            // å…·ä½“çš„è½¬æ¢åˆ†æ
            if (currentInputFormat === 'ushort' && result.dataType === 'int') {
                html += `
                        <div class="principle-item">
                            <strong>${t('data_analysis')}</strong>
                            <span>${t('ushort_to_int_analysis')}</span>
                        </div>
                `;
            } else if (currentInputFormat === 'int' && result.dataType === 'ushort') {
                html += `
                        <div class="principle-item">
                            <strong>${t('data_analysis')}</strong>
                            <span>${t('int_to_ushort_analysis')}</span>
                        </div>
                `;
            }
            
            // å­—èŠ‚åºè¯´æ˜
            html += `
                        <div class="principle-item">
                            <strong>${t('byte_order_explanation')}</strong>
                            <div style="margin-top: 8px;">
                                <div>â€¢ <strong>ABCD:</strong> ${t('big_endian_desc')}</div>
                                <div>â€¢ <strong>DCBA:</strong> ${t('little_endian_desc')}</div>
                                <div>â€¢ <strong>CDAB:</strong> ${t('middle_endian_ab_desc')}</div>
                                <div>â€¢ <strong>BADC:</strong> ${t('middle_endian_dc_desc')}</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // å†…å­˜å¸ƒå±€å±•ç¤º
            if (bytes.length > 0) {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">ğŸ’¾ ${t('memory_layout_analysis')}</div>
                        <div class="memory-layout">
                            <div class="memory-step">${t('original_data')}: [${currentData.slice(0, 5).join(', ')}${currentData.length > 5 ? '...' : ''}]</div>
                            <div class="memory-step">${t('byte_representation')}: [${bytes.slice(0, 20).map(b => '0x' + b.toString(16).padStart(2, '0')).join(', ')}${bytes.length > 20 ? '...' : ''}]</div>
                `;
                
                if (result.dataType === 'float' && bytes.length >= 4) {
                    const firstFourBytes = bytes.slice(0, 4);
                    html += `
                            <div class="memory-step">
                                ${t('float_conversion_example')} (å‰4å­—èŠ‚):
                                <div style="margin-top: 5px;">
                                    DCBA${t('order')}: <span class="memory-bytes">[${firstFourBytes.map(b => '0x' + b.toString(16).padStart(2, '0')).join('][')}]}</span> â†’ ${getFloatFromBytes(firstFourBytes, 'DCBA')}
                                </div>
                                <div>
                                    ABCD${t('order')}: <span class="memory-bytes">[${firstFourBytes.slice().reverse().map(b => '0x' + b.toString(16).padStart(2, '0')).join('][')}]}</span> â†’ ${getFloatFromBytes(firstFourBytes, 'ABCD')}
                                </div>
                            </div>
                    `;
                }
                
                html += '</div></div>';
            }
            
            return html;
        }
        
        // ä»å­—èŠ‚æ•°ç»„è·å–æµ®ç‚¹æ•°ï¼ˆç”¨äºæ¼”ç¤ºï¼‰
        function getFloatFromBytes(bytes, byteOrder) {
            try {
                const orderedBytes = applyByteOrder([...bytes], byteOrder, 4);
                const buffer = new ArrayBuffer(4);
                const view = new DataView(buffer);
                for (let i = 0; i < 4; i++) {
                    view.setUint8(i, orderedBytes[i]);
                }
                const value = view.getFloat32(0, true);
                return isFinite(value) ? value.toFixed(6) : value.toString();
            } catch (error) {
                return t('conversion_failed');
            }
        }
        
        // å…³é—­è¯¦æƒ…æ¨¡æ€æ¡†ï¼ˆå¢å¼ºç‰ˆï¼Œæ¢å¤bodyæ»šåŠ¨ï¼‰
        function closeDetailsModal() {
            document.getElementById('detailsModal').style.display = 'none';
            // æ¢å¤bodyæ»šåŠ¨
            document.body.classList.remove('modal-open');
        }
        
        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        window.onclick = function(event) {
            const modal = document.getElementById('detailsModal');
            if (event.target === modal) {
                closeDetailsModal();
            }
        }
        
        // ESCé”®å…³é—­æ¨¡æ€æ¡†
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('detailsModal');
                if (modal.style.display === 'block') {
                    closeDetailsModal();
                }
            }
        });
        
        // æ˜¾ç¤ºç»“æœ
        function displayResults(results, targetTypeFilter, byteOrderFilter, encodingFilter) {
            const allResultsGrid = document.getElementById('allResultsGrid');
            allResultsGrid.innerHTML = '';
            
            let filteredResults = results;
            if (targetTypeFilter !== 'all') {
                filteredResults = filteredResults.filter(r => r.dataType === targetTypeFilter);
            }
            if (byteOrderFilter !== 'all') {
                filteredResults = filteredResults.filter(r => r.byteOrder === byteOrderFilter);
            }
            if (encodingFilter !== 'all') {
                filteredResults = filteredResults.filter(r => r.encoding === encodingFilter);
            }
            
            // æ›´æ–°ç­›é€‰åçš„è®¡æ•°å™¨
            updateResultCounter(filteredResults);
            
            for (let result of filteredResults) {
                const element = createResultElement(result);
                allResultsGrid.appendChild(element);
            }
        }
        
        // ç­›é€‰ç»“æœ
        function filterResults() {
            if (allResults.length === 0) return;
            
            const targetType = document.getElementById('targetType').value;
            const byteOrder = document.getElementById('byteOrder').value;
            const encoding = document.getElementById('encoding').value;
            
            displayResults(allResults, targetType, byteOrder, encoding);
        }
        
        // åŸæœ‰çš„è¾…åŠ©å‡½æ•°ä¿æŒä¸å˜
        function convertToBytes(data, inputFormat) {
            const bytes = [];
            
            for (let value of data) {
                switch (inputFormat) {
                    case 'byte':
                        bytes.push(value);
                        break;
                    case 'ushort':
                    case 'short':
                        bytes.push(value & 0xFF);
                        bytes.push((value >> 8) & 0xFF);
                        break;
                    case 'int':
                    case 'uint':
                    case 'hex':
                        bytes.push(value & 0xFF);
                        bytes.push((value >> 8) & 0xFF);
                        bytes.push((value >> 16) & 0xFF);
                        bytes.push((value >> 24) & 0xFF);
                        break;
                }
            }
            
            return bytes;
        }
        
        function convertWithParams(bytes, dataType, byteOrder, encoding) {
            try {
                const processedBytes = applyEncoding(bytes, encoding);
                if (!processedBytes.success) {
                    return { success: false };
                }
                
                const result = convertByDataType(processedBytes.data, dataType, byteOrder);
                return result;
            } catch (error) {
                return { success: false, error: error.message };
            }
        }
        
        function applyEncoding(bytes, encoding) {
            switch (encoding) {
                case 'DEC':
                    return { success: true, data: bytes };
                    
                case 'BCD':
                    for (let byte of bytes) {
                        const high = (byte >> 4) & 0xF;
                        const low = byte & 0xF;
                        if (high > 9 || low > 9) {
                            return { success: false, error: 'Invalid BCD format' };
                        }
                    }
                    
                    const bcdBytes = bytes.map(byte => {
                        const high = (byte >> 4) & 0xF;
                        const low = byte & 0xF;
                        return high * 10 + low;
                    });
                    return { success: true, data: bcdBytes };
                    
                case 'HEX':
                    return { success: true, data: bytes };
                    
                default:
                    return { success: true, data: bytes };
            }
        }
        
        function convertByDataType(bytes, dataType, byteOrder) {
            const result = [];
            
            try {
                switch (dataType) {
                    case 'bool':
                        for (let byte of bytes) {
                            for (let i = 0; i < 8; i++) {
                                result.push((byte & (1 << i)) !== 0);
                            }
                        }
                        break;
                        
                    case 'byte':
                        result.push(...bytes);
                        break;
                        
                    case 'sbyte':
                        for (let byte of bytes) {
                            result.push(byte > 127 ? byte - 256 : byte);
                        }
                        break;
                        
                    case 'short':
                    case 'ushort':
                        for (let i = 0; i < bytes.length - 1; i += 2) {
                            const orderedBytes = applyByteOrder([bytes[i], bytes[i + 1]], byteOrder, 2);
                            const value = orderedBytes[0] | (orderedBytes[1] << 8);
                            result.push(dataType === 'short' && value > 32767 ? value - 65536 : value);
                        }
                        break;
                        
                    case 'int':
                    case 'uint':
                        for (let i = 0; i < bytes.length - 3; i += 4) {
                            const orderedBytes = applyByteOrder([bytes[i], bytes[i + 1], bytes[i + 2], bytes[i + 3]], byteOrder, 4);
                            const value = orderedBytes[0] | (orderedBytes[1] << 8) | (orderedBytes[2] << 16) | (orderedBytes[3] << 24);
                            result.push(dataType === 'int' && value > 2147483647 ? value - 4294967296 : value >>> 0);
                        }
                        break;
                        
                    case 'long':
                    case 'ulong':
                        for (let i = 0; i < bytes.length - 7; i += 8) {
                            const orderedBytes = applyByteOrder(bytes.slice(i, i + 8), byteOrder, 8);
                            let value = BigInt(0);
                            for (let j = 0; j < 8; j++) {
                                value |= BigInt(orderedBytes[j]) << BigInt(j * 8);
                            }
                            result.push(Number(value));
                        }
                        break;
                        
                    case 'float':
                        for (let i = 0; i < bytes.length - 3; i += 4) {
                            const orderedBytes = applyByteOrder([bytes[i], bytes[i + 1], bytes[i + 2], bytes[i + 3]], byteOrder, 4);
                            const buffer = new ArrayBuffer(4);
                            const view = new DataView(buffer);
                            for (let j = 0; j < 4; j++) {
                                view.setUint8(j, orderedBytes[j]);
                            }
                            const floatValue = view.getFloat32(0, true);
                            result.push(floatValue);
                        }
                        break;
                        
                    case 'double':
                        for (let i = 0; i < bytes.length - 7; i += 8) {
                            const orderedBytes = applyByteOrder(bytes.slice(i, i + 8), byteOrder, 8);
                            const buffer = new ArrayBuffer(8);
                            const view = new DataView(buffer);
                            for (let j = 0; j < 8; j++) {
                                view.setUint8(j, orderedBytes[j]);
                            }
                            const doubleValue = view.getFloat64(0, true);
                            result.push(doubleValue);
                        }
                        break;
                        
                    case 'ascii':
                        const asciiString = bytes.map(byte => 
                            byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : 'Â·'
                        ).join('');
                        result.push(asciiString);
                        break;
                }
                
                const displayValue = formatDisplayValue(result, dataType);
                const isValid = validateResult(result, dataType);
                
                return {
                    success: true,
                    data: result,
                    displayValue: displayValue,
                    isValid: isValid
                };
                
            } catch (error) {
                return { success: false, error: error.message };
            }
        }
        
        function applyByteOrder(bytes, byteOrder, expectedLength) {
            const paddedBytes = [...bytes];
            while (paddedBytes.length < expectedLength) {
                paddedBytes.push(0);
            }
            
            switch (byteOrder) {
                case 'ABCD':
                    return paddedBytes.reverse();
                case 'DCBA':
                    return paddedBytes;
                case 'CDAB':
                    if (expectedLength === 4) {
                        return [paddedBytes[2], paddedBytes[3], paddedBytes[0], paddedBytes[1]];
                    } else if (expectedLength === 2) {
                        return [paddedBytes[1], paddedBytes[0]];
                    } else if (expectedLength === 8) {
                        return [paddedBytes[6], paddedBytes[7], paddedBytes[4], paddedBytes[5], paddedBytes[2], paddedBytes[3], paddedBytes[0], paddedBytes[1]];
                    }
                    return paddedBytes;
                case 'BADC':
                    if (expectedLength === 4) {
                        return [paddedBytes[1], paddedBytes[0], paddedBytes[3], paddedBytes[2]];
                    } else if (expectedLength === 2) {
                        return [paddedBytes[1], paddedBytes[0]];
                    } else if (expectedLength === 8) {
                        return [paddedBytes[1], paddedBytes[0], paddedBytes[3], paddedBytes[2], paddedBytes[5], paddedBytes[4], paddedBytes[7], paddedBytes[6]];
                    }
                    return paddedBytes;
                default:
                    return paddedBytes;
            }
        }
        
        function formatDisplayValue(result, dataType) {
            if (result.length === 0) return '';
            
            switch (dataType) {
                case 'float':
                case 'double':
                    return result.map(v => {
                        if (isNaN(v) || !isFinite(v)) {
                            return v.toString();
                        }
                        return parseFloat(v.toFixed(6));
                    }).join(', ');
                case 'bool':
                    return result.slice(0, 32).map(v => v ? '1' : '0').join('');
                case 'ascii':
                    return result[0];
                default:
                    return result.join(', ');
            }
        }
        
        function validateResult(result, dataType) {
            if (result.length === 0) return false;
            
            switch (dataType) {
                case 'float':
                case 'double':
                    return result.some(v => isFinite(v) && !isNaN(v) && Math.abs(v) < 1e10);
                case 'ascii':
                    return /[a-zA-Z0-9]/.test(result[0]);
                default:
                    return true;
            }
        }
        
        function displayRawData() {
            const rawDataDisplay = document.getElementById('rawDataDisplay');
            const bytes = convertToBytes(currentData, currentInputFormat);
            
            rawDataDisplay.innerHTML = `
                <div class="process-step">
                    <div class="step-title">ğŸ“¥ ${t('input_data')} (${currentInputFormat})</div>
                    <div class="step-content">[${currentData.join(', ')}]</div>
                </div>
                <div class="process-step">
                    <div class="step-title">ğŸ”¢ ${t('convert_to_byte_array')}</div>
                    <div class="step-content">[${bytes.join(', ')}]</div>
                </div>
                <div class="process-step">
                    <div class="step-title">ğŸ”¤ ${t('hex_representation')}</div>
                    <div class="step-content">[${bytes.map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase()).join(', ')}]</div>
                </div>
                <div class="process-step">
                    <div class="step-title">ğŸ’¾ ${t('binary_representation')}</div>
                    <div class="step-content">[${bytes.map(b => '0b' + b.toString(2).padStart(8, '0')).join(', ')}]</div>
                </div>
            `;
        }
        
        function copyResult(text) {
            navigator.clipboard.writeText(text).then(() => {
                console.log('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
            });
        }
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
        
        // ç¨‹åºåŒ–åˆ‡æ¢æ ‡ç­¾ï¼ˆä¸ä¾èµ–eventå¯¹è±¡ï¼‰
        function switchTabProgrammatically(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // æ ¹æ®æ ‡ç­¾åæ‰¾åˆ°å¯¹åº”çš„æŒ‰é’®å¹¶æ¿€æ´»
            const tabMapping = {
                'smart-results': 0,
                'all-results': 1,
                'raw-data': 2
            };
            
            const buttons = document.querySelectorAll('.tab-btn');
            const targetIndex = tabMapping[tabName];
            if (targetIndex !== undefined && buttons[targetIndex]) {
                buttons[targetIndex].classList.add('active');
            }
            
            document.getElementById(tabName).classList.add('active');
        }
        
        // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
        function clearPreviousResults() {
            allResults = [];
            document.getElementById('allResultsGrid').innerHTML = '';
            document.getElementById('smartResultsGrid').innerHTML = '';
            document.getElementById('rawDataDisplay').innerHTML = '';
            document.getElementById('statisticsPanel').style.display = 'none';
            updateResultCounter(null); // éšè—è®¡æ•°å™¨
        }
        
        function clearInput() {
            document.getElementById('rawData').value = '';
            document.getElementById('inputValidation').innerHTML = '';
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('smartDetection').style.display = 'none';
            document.getElementById('recommendationPanel').style.display = 'none';
            document.getElementById('autoSelectNotice').style.display = 'none';
            
            // æ¸…ç©ºæ‰€æœ‰ç›¸å…³æ•°æ®å’Œç»“æœ
            currentData = [];
            smartAnalysisResults = {};
            recommendedConfigs = [];
            clearPreviousResults();
        }
    </script>
</body>
</html>