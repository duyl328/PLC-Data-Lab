<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½PLCæ•°æ®æ ¼å¼è½¬æ¢ä¸è°ƒè¯•å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }
        
        .input-section, .control-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border: 1px solid #e0e6ed;
        }
        
        .section-title {
            font-size: 1.4em;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #34495e;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.3);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
        }
        
        .btn-smart {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        
        /* æ™ºèƒ½æ£€æµ‹é¢æ¿æ ·å¼ - ç´§å‡‘ç‰ˆ */
        .smart-detection {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 2px solid #17a2b8;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }
        
        .smart-detection::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, #17a2b8, #138496);
        }
        
        .detection-header {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .detection-results {
            display: grid;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .detection-results::-webkit-scrollbar {
            width: 6px;
        }
        
        .detection-results::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .detection-results::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }
        
        .detection-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }
        
        .detection-category {
            font-weight: 600;
            color: #495057;
            margin-top: 8px;
            margin-bottom: 4px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .confidence-high {
            border-left: 3px solid #28a745;
            background: linear-gradient(90deg, rgba(40, 167, 69, 0.08), white);
        }
        
        .confidence-medium {
            border-left: 3px solid #ffc107;
            background: linear-gradient(90deg, rgba(255, 193, 7, 0.08), white);
        }
        
        .confidence-low {
            border-left: 3px solid #dc3545;
            background: linear-gradient(90deg, rgba(220, 53, 69, 0.08), white);
        }
        
        .confidence-badge {
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            color: white;
        }
        
        .badge-high {
            background: #28a745;
        }
        
        .badge-medium {
            background: #ffc107;
        }
        
        .badge-low {
            background: #dc3545;
        }
        
        .recommendation-panel {
            background: linear-gradient(135deg, #e8f5e8, #f0f8f0);
            border: 2px solid #28a745;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .recommendation-header {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            color: #155724;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .recommended-item {
            background: white;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 10px;
            margin: 8px 0;
            position: relative;
            font-size: 13px;
        }
        
        .recommended-badge {
            position: absolute;
            top: -6px;
            right: 10px;
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }
        
        .results-section {
            grid-column: 1 / -1;
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border: 1px solid #e0e6ed;
            margin-top: 20px;
        }
        
        .results-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ecf0f1;
        }
        
        .tab-btn {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            color: #7f8c8d;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .tab-btn.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }
        
        .tab-btn.smart {
            color: #e74c3c;
        }
        
        .tab-btn.smart.active {
            border-bottom-color: #e74c3c;
        }
        
        /* Tabè®¡æ•°å™¨æ ·å¼ */
        .tab-counter {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            min-width: 18px;
            height: 18px;
            font-size: 11px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .result-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .result-item:hover {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateY(-2px);
        }
        
        .result-item.recommended {
            border: 2px solid #28a745;
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), #f8f9fa);
        }
        
        .result-item.failed {
            opacity: 0.5;
            border-color: #dc3545;
            background: linear-gradient(135deg, rgba(220, 53, 69, 0.1), #f8f9fa);
        }
        
        .result-header {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-header-sub{
            /*max-width: 210px;*/
        }
        
        .result-value {
            font-family: 'Consolas', 'Monaco', monospace;
            background: white;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            word-break: break-all;
            font-size: 13px;
        }
        
        .copy-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .copy-btn:hover {
            background: #138496;
        }
        
        .details-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 4px;
        }
        
        .details-btn:hover {
            background: #1e7e34;
        }
        
        .success-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .success-indicator.success {
            background: #28a745;
        }
        
        .success-indicator.warning {
            background: #ffc107;
        }
        
        .success-indicator.error {
            background: #dc3545;
        }
        
        /* è¯¦æƒ…æ¨¡æ€æ¡†æ ·å¼ - å¢å¤§å°ºå¯¸ */
        .details-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 0;
            border-radius: 15px;
            width: 95%;
            max-width: 1200px;
            max-height: 95vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .modal-header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 20px 30px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            font-size: 1.5em;
            font-weight: 600;
            margin: 0;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .close-btn:hover {
            transform: rotate(90deg);
            opacity: 0.7;
        }
        
        .modal-body {
            padding: 25px 30px;
            max-height: 75vh;
            overflow-y: auto;
        }
        
        .modal-body::-webkit-scrollbar {
            width: 8px;
        }
        
        .modal-body::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .modal-body::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        /* è¯¦æƒ…å†…å®¹æ ·å¼ */
        .detail-section {
            margin-bottom: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #3498db;
        }
        
        .detail-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .byteorder-test {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .byteorder-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        
        .byteorder-item:last-child {
            border-bottom: none;
        }
        
        .byteorder-label {
            font-weight: 600;
            color: #495057;
        }
        
        .byteorder-value {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #f1f3f4;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .byteorder-status {
            font-size: 18px;
        }
        
        .principle-box {
            background: #e8f5e8;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .principle-item {
            margin: 8px 0;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }
        
        .principle-item strong {
            min-width: 100px;
            color: #155724;
        }
        
        .memory-layout {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .memory-step {
            margin: 5px 0;
            padding: 5px 0;
        }
        
        .memory-bytes {
            background: #fff;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            display: inline-block;
            margin: 0 5px;
            font-weight: 600;
        }
        
        /* åŸå§‹æ•°æ®å±•ç¤ºæ ·å¼ */
        .process-step {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .process-step:hover {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(5px);
        }
        
        .step-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .step-content {
            font-family: 'Consolas', 'Monaco', monospace;
            background: white;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            word-break: break-all;
            color: #495057;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .error {
            color: #e74c3c;
            background: #fadbd8;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .statistics-panel {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat-item {
            text-align: center;
            background: white;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #ffecb5;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: #856404;
        }
        
        .stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        
        /* è‡ªåŠ¨é€‰æ‹©æç¤º */
        .auto-select-notice {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 10px 0;
            font-size: 12px;
            color: #0c5460;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .auto-select-notice::before {
            content: 'â„¹ï¸';
        }
        
        /* ç¦ç”¨bodyæ»šåŠ¨ */
        .modal-open {
            overflow: hidden;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 20px;
            }
            
            .container {
                margin: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .result-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-content {
                width: 98%;
                margin: 1% auto;
            }
            
            .modal-header {
                padding: 15px 20px;
            }
            
            .modal-body {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>PLCæ•°æ®æ ¼å¼è½¬æ¢å·¥å…·</h1>
            <p>æ•°æ®æ ¼å¼æ£€æµ‹ã€è½¬æ¢ä¸æ™ºèƒ½æ¨èç³»ç»Ÿ</p>
        </div>
        
        <div class="main-content">
            <!-- æ•°æ®è¾“å…¥åŒº -->
            <div class="input-section">
                <div class="section-title">
                    ğŸ“¥ æ•°æ®è¾“å…¥åŒº
                </div>
                
                <div class="form-group">
                    <label>è¾“å…¥æ ¼å¼é€‰æ‹©ï¼š</label>
                    <select id="inputFormat">
                        <option value="byte">byte[] (0-255)</option>
                        <option value="ushort" selected>ushort[] (0-65535)</option>
                        <option value="short">short[] (-32768 to 32767)</option>
                        <option value="int">int[] (-2147483648 to 2147483647)</option>
                        <option value="uint">uint[] (0 to 4294967295)</option>
                        <option value="hex">Hex å­—ç¬¦ä¸²</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>åŸå§‹æ•°æ®è¾“å…¥ï¼š</label>
                    <textarea id="rawData" placeholder="ç¤ºä¾‹ï¼š[13312,0,16128,0,13312,0,8704,0,5888,0]&#10;æˆ–è€…ï¼š0x3400,0x0000,0x3F00,0x0000&#10;æ”¯æŒé€—å·ã€ç©ºæ ¼ã€æ¢è¡Œåˆ†éš”"></textarea>
                </div>
                
                <div class="form-group">
                    <button class="btn btn-smart" onclick="intelligentAnalysis()">ğŸ§  æ™ºèƒ½åˆ†æ</button>
                    <button class="btn" onclick="parseInput()">ğŸ“Š è§£ææ•°æ®</button>
                    <button class="btn btn-secondary" onclick="clearInput()">ğŸ—‘ï¸ æ¸…ç©º</button>
                </div>
                
                <div id="inputValidation"></div>
                
                <!-- æ™ºèƒ½æ£€æµ‹ç»“æœé¢æ¿ - ç§»åˆ°è¾“å…¥åŒºä¸‹æ–¹ -->
                <div id="smartDetection" class="smart-detection" style="display: none;">
                    <div class="detection-header">
                        ğŸ” æ™ºèƒ½æ£€æµ‹ç»“æœ
                    </div>
                    <div id="detectionResults" class="detection-results"></div>
                </div>
            </div>
            
            <!-- æ§åˆ¶é€‰é¡¹åŒº -->
            <div class="control-section">
                <div class="section-title">
                    âš™ï¸ è½¬æ¢æ§åˆ¶
                </div>
                
                <!-- è‡ªåŠ¨é€‰æ‹©æç¤º -->
                <div id="autoSelectNotice" class="auto-select-notice" style="display: none;">
                    å·²æ ¹æ®æ™ºèƒ½æ£€æµ‹ç»“æœè‡ªåŠ¨é€‰æ‹©æœ€ä¼˜é…ç½®
                </div>
                
                <div class="form-group">
                    <label>ç›®æ ‡æ•°æ®ç±»å‹ï¼š</label>
                    <select id="targetType" onchange="filterResults()">
                        <option value="all">ğŸ”„ æ˜¾ç¤ºæ‰€æœ‰ç±»å‹</option>
                        <option value="bool">bool (å¸ƒå°”)</option>
                        <option value="byte">byte (æ— ç¬¦å·8ä½)</option>
                        <option value="sbyte">sbyte (æœ‰ç¬¦å·8ä½)</option>
                        <option value="short">short (æœ‰ç¬¦å·16ä½)</option>
                        <option value="ushort">ushort (æ— ç¬¦å·16ä½)</option>
                        <option value="int">int (æœ‰ç¬¦å·32ä½)</option>
                        <option value="uint">uint (æ— ç¬¦å·32ä½)</option>
                        <option value="long">long (æœ‰ç¬¦å·64ä½)</option>
                        <option value="ulong">ulong (æ— ç¬¦å·64ä½)</option>
                        <option value="float">float (32ä½æµ®ç‚¹)</option>
                        <option value="double">double (64ä½æµ®ç‚¹)</option>
                        <option value="ascii">ASCII å­—ç¬¦ä¸²</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>å­—èŠ‚åºé€‰æ‹©ï¼š</label>
                    <select id="byteOrder" onchange="filterResults()">
                        <option value="all">ğŸ”„ æ˜¾ç¤ºæ‰€æœ‰å­—èŠ‚åº</option>
                        <option value="ABCD">ABCD (å¤§ç«¯åº)</option>
                        <option value="DCBA">DCBA (å°ç«¯åº)</option>
                        <option value="CDAB">CDAB (è¥¿é—¨å­å¸¸è§)</option>
                        <option value="BADC">BADC (æ¬§å§†é¾™å¸¸è§)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>ç¼–ç æ ¼å¼ï¼š</label>
                    <select id="encoding" onchange="filterResults()">
                        <option value="all">ğŸ”„ æ˜¾ç¤ºæ‰€æœ‰ç¼–ç </option>
                        <option value="DEC">DEC (åè¿›åˆ¶ç¼–ç )</option>
                        <option value="BCD">BCD (äºŒè¿›åˆ¶ç¼–ç åè¿›åˆ¶)</option>
                        <option value="HEX">HEX (åå…­è¿›åˆ¶ç¼–ç )</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <button class="btn btn-success" onclick="convertData()">ğŸš€ è½¬æ¢</button>
                </div>
                
                <!-- æ¨èé…ç½®é¢æ¿ -->
                <div id="recommendationPanel" class="recommendation-panel" style="display: none;">
                    <div class="recommendation-header">
                        â­ æ™ºèƒ½æ¨èé…ç½®
                    </div>
                    <div id="recommendedConfigs"></div>
                    <button class="btn btn-success" onclick="applyRecommendation()">âœ… åº”ç”¨æ¨èé…ç½®</button>
                </div>
            </div>
        </div>
        
        <!-- ç»“æœå±•ç¤ºåŒº -->
        <div class="results-section" id="resultsSection" style="display: none;">
            <div class="section-title">
                ğŸ“Š è½¬æ¢ç»“æœ
            </div>
            
            <!-- ç»Ÿè®¡ä¿¡æ¯é¢æ¿ -->
            <div id="statisticsPanel" class="statistics-panel" style="display: none;">
                <h4>ğŸ“ˆ è½¬æ¢ç»Ÿè®¡</h4>
                <div id="statisticsGrid" class="stats-grid"></div>
            </div>
            
            <div class="results-tabs">
                <button class="tab-btn smart active" onclick="switchTab('smart-results')">ğŸ§  æ™ºèƒ½æ¨è</button>
                <button class="tab-btn" onclick="switchTab('all-results')">
                    è½¬æ¢ç»“æœ
                    <span class="tab-counter" id="allResultsCounter" style="display: none;">0</span>
                </button>
                <button class="tab-btn" onclick="switchTab('raw-data')">åŸå§‹æ•°æ®</button>
            </div>
            
            <div id="smart-results" class="tab-content active">
                <div id="smartResultsGrid" class="result-grid"></div>
            </div>
            
            <div id="all-results" class="tab-content">
                <div id="allResultsGrid" class="result-grid"></div>
            </div>
            
            <div id="raw-data" class="tab-content">
                <div id="rawDataDisplay"></div>
            </div>
        </div>
    </div>

    <!-- è¯¦æƒ…æ¨¡æ€æ¡† -->
    <div id="detailsModal" class="details-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">è½¬æ¢è¯¦æƒ…</h2>
                <button class="close-btn" onclick="closeDetailsModal()">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- è¯¦æƒ…å†…å®¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <script>
        let currentData = [];
        let currentInputFormat = 'ushort';
        let allResults = [];
        let smartAnalysisResults = {};
        let recommendedConfigs = [];
        
        // æ™ºèƒ½åˆ†æå‡½æ•°
        function intelligentAnalysis() {
            if (!parseInput(false)) {
                return;
            }
            
            // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
            clearPreviousResults();
            
            // æ‰§è¡Œæ™ºèƒ½æ£€æµ‹
            smartAnalysisResults = performSmartDetection();
            
            // æ˜¾ç¤ºæ£€æµ‹ç»“æœ
            displaySmartDetection();
            
            // ç”Ÿæˆæ¨èé…ç½®
            generateRecommendations();
            
            // è‡ªåŠ¨åº”ç”¨æœ€ä½³é…ç½®
            autoApplyBestConfig();
            
            // è‡ªåŠ¨è½¬æ¢å¹¶æ˜¾ç¤ºç»“æœ
            convertData(true);
        }
        
        // è‡ªåŠ¨åº”ç”¨æœ€ä½³é…ç½®
        function autoApplyBestConfig() {
            let bestEncoding = null;
            let bestEncodingScore = 0;
            let bestByteOrder = null;
            let bestByteOrderScore = 0;
            let bestDataType = null;
            let autoSelected = false;
            
            // æ‰¾å‡ºæœ€ä½³ç¼–ç æ ¼å¼ï¼ˆåªé€‰æ‹©é«˜ç½®ä¿¡åº¦çš„ï¼‰
            for (let [format, result] of Object.entries(smartAnalysisResults.encoding)) {
                if (result.confidence === 'high' && result.score > bestEncodingScore) {
                    bestEncoding = format;
                    bestEncodingScore = result.score;
                }
            }
            
            // æ‰¾å‡ºæœ€ä½³å­—èŠ‚åºï¼ˆåªé€‰æ‹©é«˜ç½®ä¿¡åº¦çš„ï¼‰
            for (let [order, result] of Object.entries(smartAnalysisResults.byteOrder)) {
                if (result.confidence === 'high' && result.score > bestByteOrderScore) {
                    bestByteOrder = order;
                    bestByteOrderScore = result.score;
                }
            }
            
            // æ ¹æ®æ¨èé…ç½®ç¡®å®šæœ€ä½³æ•°æ®ç±»å‹
            if (recommendedConfigs.length > 0 && recommendedConfigs[0].confidence === 'high') {
                bestDataType = recommendedConfigs[0].dataType;
            }
            
            // åº”ç”¨é«˜ç½®ä¿¡åº¦çš„é…ç½®
            if (bestEncoding && bestEncodingScore > 80) {
                document.getElementById('encoding').value = bestEncoding;
                autoSelected = true;
            }
            
            if (bestByteOrder && bestByteOrderScore > 70) {
                document.getElementById('byteOrder').value = bestByteOrder;
                autoSelected = true;
            }
            
            if (bestDataType) {
                document.getElementById('targetType').value = bestDataType;
                autoSelected = true;
            }
            
            // æ˜¾ç¤ºè‡ªåŠ¨é€‰æ‹©æç¤º
            if (autoSelected) {
                document.getElementById('autoSelectNotice').style.display = 'flex';
                setTimeout(() => {
                    document.getElementById('autoSelectNotice').style.display = 'none';
                }, 5000);
            }
        }
        
        // æ‰§è¡Œæ™ºèƒ½æ£€æµ‹
        function performSmartDetection() {
            const bytes = convertToBytes(currentData, currentInputFormat);
            const analysis = {
                encoding: analyzeEncoding(bytes),
                byteOrder: analyzeByteOrder(bytes),
                dataType: analyzeDataType(bytes),
                patterns: analyzePatterns(bytes)
            };
            
            return analysis;
        }
        
        // åˆ†æç¼–ç æ ¼å¼
        function analyzeEncoding(bytes) {
            const results = {};
            
            // BCDæ£€æµ‹
            let bcdValid = true;
            let bcdScore = 0;
            for (let byte of bytes) {
                const high = (byte >> 4) & 0xF;
                const low = byte & 0xF;
                if (high <= 9 && low <= 9) {
                    bcdScore++;
                } else {
                    bcdValid = false;
                    break;
                }
            }
            
            if (bcdValid && bytes.length > 0) {
                results.BCD = {
                    confidence: bcdScore === bytes.length ? 'high' : 'medium',
                    score: (bcdScore / bytes.length) * 100,
                    reason: `${bcdScore}/${bytes.length} å­—èŠ‚ç¬¦åˆBCDæ ¼å¼`
                };
            } else {
                results.BCD = {
                    confidence: 'low',
                    score: 0,
                    reason: 'å­˜åœ¨éBCDæ ¼å¼å­—èŠ‚'
                };
            }
            
            // ASCIIæ£€æµ‹
            let asciiCount = 0;
            let printableCount = 0;
            for (let byte of bytes) {
                if (byte >= 0 && byte <= 127) {
                    asciiCount++;
                    if (byte >= 32 && byte <= 126) {
                        printableCount++;
                    }
                }
            }
            
            const asciiRatio = asciiCount / bytes.length;
            const printableRatio = printableCount / bytes.length;
            
            if (printableRatio > 0.7) {
                results.ASCII = {
                    confidence: 'high',
                    score: printableRatio * 100,
                    reason: `${printableCount}/${bytes.length} å­—èŠ‚ä¸ºå¯æ‰“å°å­—ç¬¦`
                };
            } else if (asciiRatio > 0.8) {
                results.ASCII = {
                    confidence: 'medium',
                    score: asciiRatio * 100,
                    reason: `${asciiCount}/${bytes.length} å­—èŠ‚ä¸ºASCIIå­—ç¬¦`
                };
            } else {
                results.ASCII = {
                    confidence: 'low',
                    score: asciiRatio * 100,
                    reason: 'ASCIIå­—ç¬¦æ¯”ä¾‹è¾ƒä½'
                };
            }
            
            // DECæ£€æµ‹ï¼ˆé»˜è®¤æ€»æ˜¯å¯èƒ½çš„ï¼‰
            results.DEC = {
                confidence: 'high',
                score: 100,
                reason: 'åè¿›åˆ¶ç¼–ç å§‹ç»ˆæœ‰æ•ˆ'
            };
            
            return results;
        }
        
        // åˆ†æå­—èŠ‚åº
        function analyzeByteOrder(bytes) {
            const results = {};
            const byteOrders = ['ABCD', 'DCBA', 'CDAB', 'BADC'];
            
            // å°è¯•å°†å­—èŠ‚è½¬æ¢ä¸ºæµ®ç‚¹æ•°ï¼Œçœ‹å“ªç§å­—èŠ‚åºäº§ç”Ÿæœ€åˆç†çš„ç»“æœ
            for (let byteOrder of byteOrders) {
                let validFloatCount = 0;
                let reasonableFloatCount = 0;
                let totalAttempts = 0;
                
                for (let i = 0; i < bytes.length - 3; i += 4) {
                    try {
                        const orderedBytes = applyByteOrder([bytes[i], bytes[i + 1], bytes[i + 2], bytes[i + 3]], byteOrder, 4);
                        const buffer = new ArrayBuffer(4);
                        const view = new DataView(buffer);
                        for (let j = 0; j < 4; j++) {
                            view.setUint8(j, orderedBytes[j]);
                        }
                        const floatValue = view.getFloat32(0, true);
                        totalAttempts++;
                        
                        if (isFinite(floatValue) && !isNaN(floatValue)) {
                            validFloatCount++;
                            // æ£€æŸ¥æ˜¯å¦ä¸ºåˆç†çš„æµ®ç‚¹æ•°ï¼ˆä¸æ˜¯æå¤§æˆ–æå°çš„æ•°ï¼‰
                            if (Math.abs(floatValue) > 0.0001 && Math.abs(floatValue) < 1000000) {
                                reasonableFloatCount++;
                            }
                        }
                    } catch (error) {
                        // å¿½ç•¥è½¬æ¢é”™è¯¯
                    }
                }
                
                let confidence = 'low';
                let score = 0;
                let reason = '';
                
                if (totalAttempts > 0) {
                    const validRatio = validFloatCount / totalAttempts;
                    const reasonableRatio = reasonableFloatCount / totalAttempts;
                    score = reasonableRatio * 100;
                    
                    if (reasonableRatio > 0.7) {
                        confidence = 'high';
                        reason = `${reasonableFloatCount}/${totalAttempts} ä¸ªæµ®ç‚¹æ•°è½¬æ¢åˆç†`;
                    } else if (validRatio > 0.5) {
                        confidence = 'medium';
                        reason = `${validFloatCount}/${totalAttempts} ä¸ªæµ®ç‚¹æ•°è½¬æ¢æœ‰æ•ˆ`;
                    } else {
                        reason = 'æµ®ç‚¹æ•°è½¬æ¢æ•ˆæœä¸ä½³';
                    }
                } else {
                    reason = 'æ•°æ®é•¿åº¦ä¸è¶³ä»¥è¿›è¡Œæµ®ç‚¹æ•°åˆ†æ';
                }
                
                results[byteOrder] = {
                    confidence: confidence,
                    score: score,
                    reason: reason
                };
            }
            
            return results;
        }
        
        // åˆ†ææ•°æ®ç±»å‹
        function analyzeDataType(bytes) {
            const results = {};
            
            // æ£€æŸ¥16ä½æ•´æ•°çš„åˆç†æ€§
            let reasonableShortCount = 0;
            let totalShorts = 0;
            for (let i = 0; i < bytes.length - 1; i += 2) {
                const value = bytes[i] | (bytes[i + 1] << 8);
                totalShorts++;
                // æ£€æŸ¥æ˜¯å¦ä¸ºåˆç†çš„16ä½æ•°å€¼èŒƒå›´
                if (value < 10000 && value > 0) {
                    reasonableShortCount++;
                }
            }
            
            if (totalShorts > 0) {
                const shortRatio = reasonableShortCount / totalShorts;
                results.short = {
                    confidence: shortRatio > 0.6 ? 'high' : shortRatio > 0.3 ? 'medium' : 'low',
                    score: shortRatio * 100,
                    reason: `${reasonableShortCount}/${totalShorts} ä¸ª16ä½å€¼åˆç†`
                };
            }
            
            // æ£€æŸ¥å­—èŠ‚çº§æ•°æ®
            let reasonableByteCount = 0;
            for (let byte of bytes) {
                if (byte > 0 && byte < 250) {
                    reasonableByteCount++;
                }
            }
            
            const byteRatio = reasonableByteCount / bytes.length;
            results.byte = {
                confidence: byteRatio > 0.8 ? 'high' : byteRatio > 0.5 ? 'medium' : 'low',
                score: byteRatio * 100,
                reason: `${reasonableByteCount}/${bytes.length} ä¸ªå­—èŠ‚å€¼åˆç†`
            };
            
            return results;
        }
        
        // åˆ†ææ•°æ®æ¨¡å¼
        function analyzePatterns(bytes) {
            const patterns = {};
            
            // æ£€æŸ¥é‡å¤æ¨¡å¼
            const counts = {};
            for (let byte of bytes) {
                counts[byte] = (counts[byte] || 0) + 1;
            }
            
            const uniqueValues = Object.keys(counts).length;
            const maxRepeats = Math.max(...Object.values(counts));
            
            patterns.repetition = {
                uniqueValues: uniqueValues,
                maxRepeats: maxRepeats,
                entropy: uniqueValues / bytes.length
            };
            
            // æ£€æŸ¥é›¶å€¼æ¨¡å¼
            const zeroCount = counts[0] || 0;
            patterns.zeros = {
                count: zeroCount,
                ratio: zeroCount / bytes.length
            };
            
            return patterns;
        }
        
        // æ˜¾ç¤ºæ™ºèƒ½æ£€æµ‹ç»“æœ - ç´§å‡‘ç‰ˆ
        function displaySmartDetection() {
            const panel = document.getElementById('smartDetection');
            const results = document.getElementById('detectionResults');
            
            let html = '';
            
            // ç¼–ç æ ¼å¼æ£€æµ‹ç»“æœ - åªæ˜¾ç¤ºé«˜ç½®ä¿¡åº¦çš„
            const highConfidenceEncodings = Object.entries(smartAnalysisResults.encoding)
                .filter(([_, result]) => result.confidence !== 'low')
                .sort((a, b) => b[1].score - a[1].score);
            
            if (highConfidenceEncodings.length > 0) {
                html += '<div class="detection-category">ç¼–ç æ ¼å¼</div>';
                for (let [format, result] of highConfidenceEncodings.slice(0, 3)) {
                    const confidenceClass = `confidence-${result.confidence}`;
                    const badgeClass = `badge-${result.confidence}`;
                    
                    html += `
                        <div class="detection-item ${confidenceClass}">
                            <div>
                                <strong>${format}</strong> - ${result.reason}
                            </div>
                            <div>
                                <span class="confidence-badge ${badgeClass}">${Math.round(result.score)}%</span>
                            </div>
                        </div>
                    `;
                }
            }
            
            // å­—èŠ‚åºæ£€æµ‹ç»“æœ - åªæ˜¾ç¤ºé«˜ç½®ä¿¡åº¦çš„
            const highConfidenceByteOrders = Object.entries(smartAnalysisResults.byteOrder)
                .filter(([_, result]) => result.confidence !== 'low')
                .sort((a, b) => b[1].score - a[1].score);
                
            if (highConfidenceByteOrders.length > 0) {
                html += '<div class="detection-category">å­—èŠ‚åº</div>';
                for (let [order, result] of highConfidenceByteOrders.slice(0, 3)) {
                    const confidenceClass = `confidence-${result.confidence}`;
                    const badgeClass = `badge-${result.confidence}`;
                    
                    html += `
                        <div class="detection-item ${confidenceClass}">
                            <div>
                                <strong>${order}</strong> - ${result.reason}
                            </div>
                            <div>
                                <span class="confidence-badge ${badgeClass}">${Math.round(result.score)}%</span>
                            </div>
                        </div>
                    `;
                }
            }
            
            results.innerHTML = html || '<div class="detection-item">æœªå‘ç°é«˜ç½®ä¿¡åº¦çš„æ ¼å¼ç‰¹å¾</div>';
            panel.style.display = 'block';
        }
        
        // ç”Ÿæˆæ¨èé…ç½®
        function generateRecommendations() {
            recommendedConfigs = [];
            
            // æ‰¾å‡ºæœ€ä½³ç¼–ç æ ¼å¼
            let bestEncoding = 'DEC';
            let bestEncodingScore = 0;
            for (let [format, result] of Object.entries(smartAnalysisResults.encoding)) {
                if (result.score > bestEncodingScore && result.confidence !== 'low') {
                    bestEncoding = format;
                    bestEncodingScore = result.score;
                }
            }
            
            // æ‰¾å‡ºæœ€ä½³å­—èŠ‚åº
            let bestByteOrder = 'DCBA';
            let bestByteOrderScore = 0;
            for (let [order, result] of Object.entries(smartAnalysisResults.byteOrder)) {
                if (result.score > bestByteOrderScore) {
                    bestByteOrder = order;
                    bestByteOrderScore = result.score;
                }
            }
            
            // ç”Ÿæˆæ¨èé…ç½®
            if (smartAnalysisResults.encoding.ASCII.confidence === 'high') {
                recommendedConfigs.push({
                    encoding: 'DEC',
                    byteOrder: 'DCBA',
                    dataType: 'ascii',
                    reason: 'ASCIIå­—ç¬¦æ£€æµ‹ç½®ä¿¡åº¦é«˜ï¼Œæ¨èå­—ç¬¦ä¸²è§£æ',
                    confidence: 'high'
                });
            }
            
            if (smartAnalysisResults.encoding.BCD.confidence === 'high') {
                recommendedConfigs.push({
                    encoding: 'BCD',
                    byteOrder: bestByteOrder,
                    dataType: 'uint',
                    reason: 'BCDç¼–ç æ£€æµ‹ç½®ä¿¡åº¦é«˜ï¼Œæ¨èæ— ç¬¦å·æ•´æ•°',
                    confidence: 'high'
                });
            }
            
            // æµ®ç‚¹æ•°æ¨è
            if (bestByteOrderScore > 50) {
                recommendedConfigs.push({
                    encoding: bestEncoding,
                    byteOrder: bestByteOrder,
                    dataType: 'float',
                    reason: `${bestByteOrder}å­—èŠ‚åºæµ®ç‚¹æ•°è½¬æ¢æ•ˆæœæœ€ä½³`,
                    confidence: bestByteOrderScore > 70 ? 'high' : 'medium'
                });
            }
            
            // æ•´æ•°æ¨è
            if (smartAnalysisResults.dataType && smartAnalysisResults.dataType.short && 
                smartAnalysisResults.dataType.short.confidence !== 'low') {
                recommendedConfigs.push({
                    encoding: bestEncoding,
                    byteOrder: bestByteOrder,
                    dataType: 'ushort',
                    reason: '16ä½æ— ç¬¦å·æ•´æ•°è§£ææ•ˆæœè¾ƒå¥½',
                    confidence: smartAnalysisResults.dataType.short.confidence
                });
            }
            
            // æ˜¾ç¤ºæ¨èé…ç½®
            displayRecommendations();
        }
        
        // æ˜¾ç¤ºæ¨èé…ç½®
        function displayRecommendations() {
            const panel = document.getElementById('recommendationPanel');
            const container = document.getElementById('recommendedConfigs');
            
            if (recommendedConfigs.length === 0) {
                panel.style.display = 'none';
                return;
            }
            
            let html = '';
            recommendedConfigs.forEach((config, index) => {
                const badgeText = config.confidence === 'high' ? 'å¼ºçƒˆæ¨è' : 'æ¨è';
                html += `
                    <div class="recommended-item" data-index="${index}">
                        <div class="recommended-badge">${badgeText}</div>
                        <div>
                            <strong>${config.dataType.toUpperCase()} - ${config.byteOrder} - ${config.encoding}</strong><br>
                            <small>${config.reason}</small>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            panel.style.display = 'block';
        }
        
        // åº”ç”¨æ¨èé…ç½®
        function applyRecommendation() {
            if (recommendedConfigs.length === 0) {
                alert('æ²¡æœ‰æ¨èé…ç½®å¯åº”ç”¨');
                return;
            }
            
            // åº”ç”¨ç¬¬ä¸€ä¸ªï¼ˆæœ€ä½³ï¼‰æ¨èé…ç½®
            const config = recommendedConfigs[0];
            document.getElementById('targetType').value = config.dataType;
            document.getElementById('byteOrder').value = config.byteOrder;
            document.getElementById('encoding').value = config.encoding;
            
            // è‡ªåŠ¨è½¬æ¢
            convertData(true);
        }
        
        // è§£æè¾“å…¥æ•°æ®ï¼ˆå¢å¼ºç‰ˆï¼‰
        function parseInput(showMessage = true) {
            const rawDataElement = document.getElementById('rawData');
            const inputFormat = document.getElementById('inputFormat').value;
            const validation = document.getElementById('inputValidation');
            
            try {
                const inputText = rawDataElement.value.trim();
                if (!inputText) {
                    throw new Error('è¯·è¾“å…¥æ•°æ®');
                }
                
                // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
                clearPreviousResults();
                
                let parsedData = [];
                currentInputFormat = inputFormat;
                
                if (inputFormat === 'hex') {
                    const hexPattern = /0x[0-9A-Fa-f]+|[0-9A-Fa-f]+/g;
                    const hexMatches = inputText.match(hexPattern);
                    if (!hexMatches) {
                        throw new Error('æ— æ•ˆçš„åå…­è¿›åˆ¶æ ¼å¼');
                    }
                    parsedData = hexMatches.map(hex => {
                        const value = parseInt(hex.replace('0x', ''), 16);
                        return value;
                    });
                } else {
                    const cleanText = inputText.replace(/[\[\]]/g, '');
                    const values = cleanText.split(/[,\s\n]+/).filter(v => v.trim());
                    
                    parsedData = values.map(v => {
                        const num = v.includes('0x') ? parseInt(v, 16) : parseInt(v);
                        if (isNaN(num)) {
                            throw new Error(`æ— æ•ˆçš„æ•°å€¼: ${v}`);
                        }
                        return num;
                    });
                }
                
                validateDataRange(parsedData, inputFormat);
                currentData = parsedData;
                
                if (showMessage) {
                    validation.innerHTML = `<div class="success">âœ… æˆåŠŸè§£æ ${parsedData.length} ä¸ªæ•°æ®é¡¹</div>`;
                }
                
                return true;
                
            } catch (error) {
                if (showMessage) {
                    validation.innerHTML = `<div class="error">âŒ ${error.message}</div>`;
                }
                currentData = [];
                return false;
            }
        }
        
        // éªŒè¯æ•°æ®èŒƒå›´
        function validateDataRange(data, format) {
            const ranges = {
                'byte': [0, 255],
                'sbyte': [-128, 127],
                'ushort': [0, 65535],
                'short': [-32768, 32767],
                'int': [-2147483648, 2147483647],
                'uint': [0, 4294967295],
                'hex': [0, 4294967295]
            };
            
            if (ranges[format]) {
                const [min, max] = ranges[format];
                for (let value of data) {
                    if (value < min || value > max) {
                        throw new Error(`æ•°å€¼ ${value} è¶…å‡º ${format} ç±»å‹èŒƒå›´ [${min}, ${max}]`);
                    }
                }
            }
        }
        
        // è½¬æ¢æ•°æ®ï¼ˆå¢å¼ºç‰ˆï¼‰
        function convertData(isSmartMode = false) {
            if (currentData.length === 0) {
                alert('è¯·å…ˆè¾“å…¥å¹¶è§£ææ•°æ®');
                return;
            }
            
            const targetType = document.getElementById('targetType').value;
            const byteOrder = document.getElementById('byteOrder').value;
            const encoding = document.getElementById('encoding').value;
            
            document.getElementById('resultsSection').style.display = 'block';
            
            // ç”Ÿæˆæ‰€æœ‰ç»“æœ
            allResults = generateAllResults();
            
            // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
            const statistics = calculateStatistics();
            displayStatistics(statistics);
            
            // è‡ªåŠ¨æ»šåŠ¨åˆ°ç»“æœåŒºåŸŸå¹¶åˆ‡æ¢æ ‡ç­¾
            setTimeout(() => {
                const resultsSection = document.getElementById('resultsSection');
                resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                // åˆ‡æ¢åˆ°ç›¸åº”çš„æ ‡ç­¾
                if (!isSmartMode) {
                    switchTabProgrammatically('all-results');
                } else {
                    switchTabProgrammatically('smart-results');
                }
            }, 100);
            
            // æ˜¾ç¤ºç»“æœ
            if (isSmartMode) {
                displaySmartResults();
            } else {
                displayResults(allResults, targetType, byteOrder, encoding);
            }
            
            displayRawData();
        }
        
        // æ›´æ–°ç»“æœè®¡æ•°å™¨
        function updateResultCounter(results = null) {
            const counter = document.getElementById('allResultsCounter');
            
            if (results === null) {
                // å¦‚æœæ²¡æœ‰ä¼ å…¥ç»“æœï¼Œéšè—è®¡æ•°å™¨
                counter.style.display = 'none';
                return;
            }
            
            const validResults = results.filter(r => r.isValid).length;
            counter.textContent = validResults;
            counter.style.display = validResults > 0 ? 'flex' : 'none';
        }
        
        // ç”Ÿæˆæ‰€æœ‰è½¬æ¢ç»“æœï¼ˆå¢å¼ºç‰ˆï¼‰
        function generateAllResults() {
            const results = [];
            const byteOrders = ['ABCD', 'DCBA', 'CDAB', 'BADC'];
            const encodings = ['DEC', 'BCD', 'HEX'];
            const dataTypes = ['bool', 'byte', 'sbyte', 'short', 'ushort', 'int', 'uint', 'long', 'ulong', 'float', 'double', 'ascii'];
            
            const bytes = convertToBytes(currentData, currentInputFormat);
            
            for (let byteOrder of byteOrders) {
                for (let encoding of encodings) {
                    for (let dataType of dataTypes) {
                        try {
                            const result = convertWithParams(bytes, dataType, byteOrder, encoding);
                            if (result.success) {
                                // è®¡ç®—æ™ºèƒ½è¯„åˆ†
                                const smartScore = calculateSmartScore(result, dataType, byteOrder, encoding);
                                
                                results.push({
                                    inputFormat: currentInputFormat,
                                    dataType,
                                    byteOrder,
                                    encoding,
                                    result: result.data,
                                    displayValue: result.displayValue,
                                    isValid: result.isValid,
                                    smartScore: smartScore,
                                    isRecommended: smartScore > 70,
                                    originalBytes: bytes
                                });
                            }
                        } catch (error) {
                            // è®°å½•å¤±è´¥çš„è½¬æ¢
                            results.push({
                                inputFormat: currentInputFormat,
                                dataType,
                                byteOrder,
                                encoding,
                                result: null,
                                displayValue: 'è½¬æ¢å¤±è´¥',
                                isValid: false,
                                smartScore: 0,
                                isRecommended: false,
                                error: error.message,
                                originalBytes: bytes
                            });
                        }
                    }
                }
            }
            
            return results;
        }
        
        // è®¡ç®—æ™ºèƒ½è¯„åˆ†
        function calculateSmartScore(result, dataType, byteOrder, encoding) {
            let score = 0;
            
            // åŸºç¡€æœ‰æ•ˆæ€§è¯„åˆ†
            if (result.isValid) {
                score += 30;
            }
            
            // æ ¹æ®æ™ºèƒ½åˆ†æç»“æœåŠ åˆ†
            if (smartAnalysisResults.encoding && smartAnalysisResults.encoding[encoding]) {
                const encodingAnalysis = smartAnalysisResults.encoding[encoding];
                if (encodingAnalysis.confidence === 'high') {
                    score += 25;
                } else if (encodingAnalysis.confidence === 'medium') {
                    score += 15;
                }
            }
            
            if (smartAnalysisResults.byteOrder && smartAnalysisResults.byteOrder[byteOrder]) {
                const byteOrderAnalysis = smartAnalysisResults.byteOrder[byteOrder];
                if (byteOrderAnalysis.confidence === 'high') {
                    score += 25;
                } else if (byteOrderAnalysis.confidence === 'medium') {
                    score += 15;
                }
            }
            
            // æ•°æ®ç±»å‹ç‰¹å®šè¯„åˆ†
            if (dataType === 'float' || dataType === 'double') {
                if (result.data && result.data.length > 0) {
                    const validNumbers = result.data.filter(v => isFinite(v) && !isNaN(v) && Math.abs(v) > 0.0001 && Math.abs(v) < 1000000).length;
                    score += (validNumbers / result.data.length) * 20;
                }
            }
            
            return Math.min(100, score);
        }
        
        // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        function calculateStatistics() {
            const stats = {
                total: allResults.length,
                successful: 0,
                failed: 0,
                recommended: 0,
                byEncoding: {},
                byByteOrder: {},
                byDataType: {}
            };
            
            for (let result of allResults) {
                if (result.isValid) {
                    stats.successful++;
                } else {
                    stats.failed++;
                }
                
                if (result.isRecommended) {
                    stats.recommended++;
                }
                
                // æŒ‰åˆ†ç±»ç»Ÿè®¡
                stats.byEncoding[result.encoding] = (stats.byEncoding[result.encoding] || 0) + 1;
                stats.byByteOrder[result.byteOrder] = (stats.byByteOrder[result.byteOrder] || 0) + 1;
                stats.byDataType[result.dataType] = (stats.byDataType[result.dataType] || 0) + 1;
            }
            
            return stats;
        }
        
        // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
        function displayStatistics(stats) {
            const panel = document.getElementById('statisticsPanel');
            const grid = document.getElementById('statisticsGrid');
            
            const successRate = ((stats.successful / stats.total) * 100).toFixed(1);
            const recommendRate = ((stats.recommended / stats.total) * 100).toFixed(1);
            
            grid.innerHTML = `
                <div class="stat-item">
                    <div class="stat-value">${stats.total}</div>
                    <div class="stat-label">æ€»è½¬æ¢æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.successful}</div>
                    <div class="stat-label">æˆåŠŸè½¬æ¢</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.failed}</div>
                    <div class="stat-label">è½¬æ¢å¤±è´¥</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.recommended}</div>
                    <div class="stat-label">æ™ºèƒ½æ¨è</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${successRate}%</div>
                    <div class="stat-label">æˆåŠŸç‡</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${recommendRate}%</div>
                    <div class="stat-label">æ¨èç‡</div>
                </div>
            `;
            
            panel.style.display = 'block';
        }
        
        // æ˜¾ç¤ºæ™ºèƒ½æ¨èç»“æœ
        function displaySmartResults() {
            const grid = document.getElementById('smartResultsGrid');
            
            // æŒ‰æ™ºèƒ½è¯„åˆ†æ’åº
            const sortedResults = [...allResults].sort((a, b) => b.smartScore - a.smartScore);
            
            // åªæ˜¾ç¤ºè¯„åˆ†è¾ƒé«˜çš„ç»“æœ
            const topResults = sortedResults.filter(r => r.smartScore > 30).slice(0, 20);
            
            grid.innerHTML = '';
            for (let result of topResults) {
                const element = createResultElement(result, true);
                grid.appendChild(element);
            }
            
            if (topResults.length === 0) {
                grid.innerHTML = '<div class="result-item">æ²¡æœ‰æ‰¾åˆ°é«˜ç½®ä¿¡åº¦çš„è½¬æ¢ç»“æœ</div>';
            }
        }
        
        // åˆ›å»ºç»“æœå…ƒç´ ï¼ˆå¢å¼ºç‰ˆï¼‰
        function createResultElement(result, showSmartInfo = false) {
            const div = document.createElement('div');
            div.className = 'result-item';
            
            if (result.isRecommended) {
                div.classList.add('recommended');
            }
            
            if (!result.isValid) {
                div.classList.add('failed');
            }
            
            let smartInfo = '';
            if (showSmartInfo && result.smartScore !== undefined) {
                const scoreClass = result.smartScore > 70 ? 'success' : result.smartScore > 40 ? 'warning' : 'error';
                smartInfo = `
                    <div class="success-indicator ${scoreClass}" title="æ™ºèƒ½è¯„åˆ†: ${result.smartScore}"></div>
                `;
            }
            
            let statusIcon = 'âœ…';
            if (!result.isValid) {
                statusIcon = 'âŒ';
            } else if (result.isRecommended) {
                statusIcon = 'â­';
            }
            
            const resultIndex = allResults.indexOf(result);
            
            div.innerHTML = `
                ${smartInfo}
                <div class="result-header">
                    <span class="result-header-sub">${statusIcon} ${result.inputFormat.toUpperCase()} â†’ ${result.dataType.toUpperCase()} - ${result.byteOrder} - ${result.encoding}</span>
                    <div>
                        <button class="copy-btn" data-copy-value="${result.displayValue.replace(/"/g, '&quot;')}" onclick="copyResultFromButton(this)" title="å¤åˆ¶ç»“æœ">ğŸ“‹</button>
                        <button class="details-btn" onclick="showConversionDetails(${resultIndex})" title="æŸ¥çœ‹è¯¦æƒ…">ğŸ”</button>
                        ${showSmartInfo ? `<span style="font-size: 12px; color: #6c757d;">${result.smartScore}åˆ†</span>` : ''}
                    </div>
                </div>
                <div class="result-value">${result.displayValue}</div>
            `;
            
            return div;
        }
        
        // ä»æŒ‰é’®å¤åˆ¶ç»“æœçš„æ–°æ–¹æ³•
        function copyResultFromButton(button) {
            const value = button.getAttribute('data-copy-value').replace(/&quot;/g, '"');
            copyResult(value);
        }
        
        // æ˜¾ç¤ºè½¬æ¢è¯¦æƒ…ï¼ˆå¢å¼ºç‰ˆï¼ŒåŒ…å«ç¦ç”¨bodyæ»šåŠ¨ï¼‰
        function showConversionDetails(resultIndex) {
            const result = allResults[resultIndex];
            if (!result) return;
            
            const modal = document.getElementById('detailsModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = `${result.inputFormat.toUpperCase()} â†’ ${result.dataType.toUpperCase()} è½¬æ¢è¯¦æƒ…`;
            
            // ç”Ÿæˆè¯¦ç»†å†…å®¹
            const detailsHtml = generateConversionDetails(result);
            modalBody.innerHTML = detailsHtml;
            
            // ç¦ç”¨bodyæ»šåŠ¨
            document.body.classList.add('modal-open');
            
            modal.style.display = 'block';
        }
        
        // ç”Ÿæˆè½¬æ¢è¯¦æƒ…å†…å®¹
        function generateConversionDetails(result) {
            const bytes = result.originalBytes;
            const byteOrders = ['ABCD', 'DCBA', 'CDAB', 'BADC'];
            
            let html = `
                <div class="detail-section">
                    <div class="detail-title">ğŸ“¤ è½¬æ¢ç»“æœ</div>
                    <div class="byteorder-test">
                        <strong>å½“å‰é…ç½®ï¼š</strong>
                        <div class="byteorder-item">
                            <span class="byteorder-label">æ•°æ®ç±»å‹</span>
                            <span class="byteorder-value">${result.dataType.toUpperCase()}</span>
                            <span class="byteorder-status">${result.isValid ? 'âœ…' : 'âŒ'}</span>
                        </div>
                        <div class="byteorder-item">
                            <span class="byteorder-label">å­—èŠ‚åº</span>
                            <span class="byteorder-value">${result.byteOrder}</span>
                            <span class="byteorder-status">ğŸ”„</span>
                        </div>
                        <div class="byteorder-item">
                            <span class="byteorder-label">ç¼–ç æ ¼å¼</span>
                            <span class="byteorder-value">${result.encoding}</span>
                            <span class="byteorder-status">ğŸ¯</span>
                        </div>
                        <div class="byteorder-item">
                            <span class="byteorder-label">è½¬æ¢ç»“æœ</span>
                            <span class="byteorder-value" style="max-width: 300px; word-break: break-all;">${result.displayValue}</span>
                            <span class="byteorder-status">${result.isValid ? 'âœ…' : 'âŒ'}</span>
                        </div>
                    </div>
                </div>
            `;
            
            // æ˜¾ç¤ºæ‰€æœ‰å­—èŠ‚åºæµ‹è¯•ç»“æœ
            if (result.dataType !== 'ascii' && result.dataType !== 'bool' && result.dataType !== 'byte') {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">ğŸ§ª æ‰€æœ‰å­—èŠ‚åºæ ¼å¼æµ‹è¯•ç»“æœ</div>
                        <div class="byteorder-test">
                `;
                
                for (let byteOrder of byteOrders) {
                    try {
                        const testResult = convertWithParams(bytes, result.dataType, byteOrder, result.encoding);
                        const isSuccess = testResult.success && testResult.isValid;
                        const displayValue = testResult.success ? testResult.displayValue : 'è½¬æ¢å¤±è´¥';
                        
                        html += `
                            <div class="byteorder-item">
                                <span class="byteorder-label">${byteOrder}æ ¼å¼</span>
                                <span class="byteorder-value">[${displayValue}]</span>
                                <span class="byteorder-status">${isSuccess ? 'âœ…' : 'âŒ'}</span>
                            </div>
                        `;
                    } catch (error) {
                        html += `
                            <div class="byteorder-item">
                                <span class="byteorder-label">${byteOrder}æ ¼å¼</span>
                                <span class="byteorder-value">è½¬æ¢å¤±è´¥</span>
                                <span class="byteorder-status">âŒ</span>
                            </div>
                        `;
                    }
                }
                
                html += '</div></div>';
            }
            
            // è½¬æ¢åŸç†è¯´æ˜
            html += `
                <div class="detail-section">
                    <div class="detail-title">ğŸ“š è½¬æ¢åŸç†è¯´æ˜</div>
                    <div class="principle-box">
                        <div class="principle-item">
                            <strong>é—®é¢˜åˆ†æï¼š</strong>
                            <span>ä½ è¾“å…¥äº†${currentData.length}ä¸ª${currentInputFormat}å€¼ï¼š[${currentData.slice(0, 10).join(', ')}${currentData.length > 10 ? '...' : ''}]ï¼Œè½¬æ¢ä¸º${result.dataType}ç±»å‹ã€‚</span>
                        </div>
            `;
            
            // å…·ä½“çš„è½¬æ¢åˆ†æ
            if (currentInputFormat === 'ushort' && result.dataType === 'int') {
                html += `
                        <div class="principle-item">
                            <strong>æ•°æ®åˆ†æï¼š</strong>
                            <span>æ¯2ä¸ª16ä½ushortå€¼è¢«ç»„åˆæˆ1ä¸ª32ä½intå€¼ï¼Œè¿™å¯èƒ½æ˜¯å› ä¸ºåŸå§‹æ•°æ®æ˜¯32ä½æ•´æ•°è¢«æ‹†åˆ†è¯»å–é€ æˆçš„ã€‚</span>
                        </div>
                `;
            } else if (currentInputFormat === 'int' && result.dataType === 'ushort') {
                html += `
                        <div class="principle-item">
                            <strong>æ•°æ®åˆ†æï¼š</strong>
                            <span>æ¯ä¸ª32ä½intè¢«æ‹†åˆ†æˆ2ä¸ª16ä½ushortè¯»å–ï¼Œå¦‚æœè¯»å–ç»“æœä¸ç¬¦åˆé¢„æœŸï¼Œå¯èƒ½å­˜åœ¨å­—èŠ‚åºè½¬æ¢é—®é¢˜ã€‚</span>
                        </div>
                `;
            }
            
            // å­—èŠ‚åºè¯´æ˜
            html += `
                        <div class="principle-item">
                            <strong>å­—èŠ‚åºè¯´æ˜ï¼š</strong>
                            <div style="margin-top: 8px;">
                                <div>â€¢ <strong>ABCD (å¤§ç«¯åº)ï¼š</strong> é«˜å­—èŠ‚åœ¨å‰ï¼Œä½å­—èŠ‚åœ¨åï¼Œå¦‚ 0x12345678 å­˜å‚¨ä¸º [12][34][56][78]</div>
                                <div>â€¢ <strong>DCBA (å°ç«¯åº)ï¼š</strong> ä½å­—èŠ‚åœ¨å‰ï¼Œé«˜å­—èŠ‚åœ¨åï¼Œå¦‚ 0x12345678 å­˜å‚¨ä¸º [78][56][34][12]</div>
                                <div>â€¢ <strong>CDAB (ä¸­ç«¯åº)ï¼š</strong> å­—å¯¹äº¤æ¢çš„å¤§ç«¯åºï¼Œè¥¿é—¨å­PLCå¸¸è§</div>
                                <div>â€¢ <strong>BADC (ä¸­ç«¯åº)ï¼š</strong> å­—å¯¹äº¤æ¢çš„å°ç«¯åºï¼Œæ¬§å§†é¾™PLCå¸¸è§</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // å†…å­˜å¸ƒå±€å±•ç¤º
            if (bytes.length > 0) {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">ğŸ’¾ å†…å­˜å¸ƒå±€åˆ†æ</div>
                        <div class="memory-layout">
                            <div class="memory-step">åŸå§‹æ•°æ®: [${currentData.slice(0, 5).join(', ')}${currentData.length > 5 ? '...' : ''}]</div>
                            <div class="memory-step">å­—èŠ‚è¡¨ç¤º: [${bytes.slice(0, 20).map(b => '0x' + b.toString(16).padStart(2, '0')).join(', ')}${bytes.length > 20 ? '...' : ''}]</div>
                `;
                
                if (result.dataType === 'float' && bytes.length >= 4) {
                    const firstFourBytes = bytes.slice(0, 4);
                    html += `
                            <div class="memory-step">
                                æµ®ç‚¹æ•°è½¬æ¢ç¤ºä¾‹ (å‰4å­—èŠ‚):
                                <div style="margin-top: 5px;">
                                    DCBAé¡ºåº: <span class="memory-bytes">[${firstFourBytes.map(b => '0x' + b.toString(16).padStart(2, '0')).join('][')}]}</span> â†’ ${getFloatFromBytes(firstFourBytes, 'DCBA')}
                                </div>
                                <div>
                                    ABCDé¡ºåº: <span class="memory-bytes">[${firstFourBytes.slice().reverse().map(b => '0x' + b.toString(16).padStart(2, '0')).join('][')}]}</span> â†’ ${getFloatFromBytes(firstFourBytes, 'ABCD')}
                                </div>
                            </div>
                    `;
                }
                
                html += '</div></div>';
            }
            
            return html;
        }
        
        // ä»å­—èŠ‚æ•°ç»„è·å–æµ®ç‚¹æ•°ï¼ˆç”¨äºæ¼”ç¤ºï¼‰
        function getFloatFromBytes(bytes, byteOrder) {
            try {
                const orderedBytes = applyByteOrder([...bytes], byteOrder, 4);
                const buffer = new ArrayBuffer(4);
                const view = new DataView(buffer);
                for (let i = 0; i < 4; i++) {
                    view.setUint8(i, orderedBytes[i]);
                }
                const value = view.getFloat32(0, true);
                return isFinite(value) ? value.toFixed(6) : value.toString();
            } catch (error) {
                return 'è½¬æ¢å¤±è´¥';
            }
        }
        
        // å…³é—­è¯¦æƒ…æ¨¡æ€æ¡†ï¼ˆå¢å¼ºç‰ˆï¼Œæ¢å¤bodyæ»šåŠ¨ï¼‰
        function closeDetailsModal() {
            document.getElementById('detailsModal').style.display = 'none';
            // æ¢å¤bodyæ»šåŠ¨
            document.body.classList.remove('modal-open');
        }
        
        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        window.onclick = function(event) {
            const modal = document.getElementById('detailsModal');
            if (event.target === modal) {
                closeDetailsModal();
            }
        }
        
        // ESCé”®å…³é—­æ¨¡æ€æ¡†
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('detailsModal');
                if (modal.style.display === 'block') {
                    closeDetailsModal();
                }
            }
        });
        
        // æ˜¾ç¤ºç»“æœ
        function displayResults(results, targetTypeFilter, byteOrderFilter, encodingFilter) {
            const allResultsGrid = document.getElementById('allResultsGrid');
            allResultsGrid.innerHTML = '';
            
            let filteredResults = results;
            if (targetTypeFilter !== 'all') {
                filteredResults = filteredResults.filter(r => r.dataType === targetTypeFilter);
            }
            if (byteOrderFilter !== 'all') {
                filteredResults = filteredResults.filter(r => r.byteOrder === byteOrderFilter);
            }
            if (encodingFilter !== 'all') {
                filteredResults = filteredResults.filter(r => r.encoding === encodingFilter);
            }
            
            // æ›´æ–°ç­›é€‰åçš„è®¡æ•°å™¨
            updateResultCounter(filteredResults);
            
            for (let result of filteredResults) {
                const element = createResultElement(result);
                allResultsGrid.appendChild(element);
            }
        }
        
        // ç­›é€‰ç»“æœ
        function filterResults() {
            if (allResults.length === 0) return;
            
            const targetType = document.getElementById('targetType').value;
            const byteOrder = document.getElementById('byteOrder').value;
            const encoding = document.getElementById('encoding').value;
            
            displayResults(allResults, targetType, byteOrder, encoding);
        }
        
        // åŸæœ‰çš„è¾…åŠ©å‡½æ•°ä¿æŒä¸å˜
        function convertToBytes(data, inputFormat) {
            const bytes = [];
            
            for (let value of data) {
                switch (inputFormat) {
                    case 'byte':
                        bytes.push(value);
                        break;
                    case 'ushort':
                    case 'short':
                        bytes.push(value & 0xFF);
                        bytes.push((value >> 8) & 0xFF);
                        break;
                    case 'int':
                    case 'uint':
                    case 'hex':
                        bytes.push(value & 0xFF);
                        bytes.push((value >> 8) & 0xFF);
                        bytes.push((value >> 16) & 0xFF);
                        bytes.push((value >> 24) & 0xFF);
                        break;
                }
            }
            
            return bytes;
        }
        
        function convertWithParams(bytes, dataType, byteOrder, encoding) {
            try {
                const processedBytes = applyEncoding(bytes, encoding);
                if (!processedBytes.success) {
                    return { success: false };
                }
                
                const result = convertByDataType(processedBytes.data, dataType, byteOrder);
                return result;
            } catch (error) {
                return { success: false, error: error.message };
            }
        }
        
        function applyEncoding(bytes, encoding) {
            switch (encoding) {
                case 'DEC':
                    return { success: true, data: bytes };
                    
                case 'BCD':
                    for (let byte of bytes) {
                        const high = (byte >> 4) & 0xF;
                        const low = byte & 0xF;
                        if (high > 9 || low > 9) {
                            return { success: false, error: 'Invalid BCD format' };
                        }
                    }
                    
                    const bcdBytes = bytes.map(byte => {
                        const high = (byte >> 4) & 0xF;
                        const low = byte & 0xF;
                        return high * 10 + low;
                    });
                    return { success: true, data: bcdBytes };
                    
                case 'HEX':
                    return { success: true, data: bytes };
                    
                default:
                    return { success: true, data: bytes };
            }
        }
        
        function convertByDataType(bytes, dataType, byteOrder) {
            const result = [];
            
            try {
                switch (dataType) {
                    case 'bool':
                        for (let byte of bytes) {
                            for (let i = 0; i < 8; i++) {
                                result.push((byte & (1 << i)) !== 0);
                            }
                        }
                        break;
                        
                    case 'byte':
                        result.push(...bytes);
                        break;
                        
                    case 'sbyte':
                        for (let byte of bytes) {
                            result.push(byte > 127 ? byte - 256 : byte);
                        }
                        break;
                        
                    case 'short':
                    case 'ushort':
                        for (let i = 0; i < bytes.length - 1; i += 2) {
                            const orderedBytes = applyByteOrder([bytes[i], bytes[i + 1]], byteOrder, 2);
                            const value = orderedBytes[0] | (orderedBytes[1] << 8);
                            result.push(dataType === 'short' && value > 32767 ? value - 65536 : value);
                        }
                        break;
                        
                    case 'int':
                    case 'uint':
                        for (let i = 0; i < bytes.length - 3; i += 4) {
                            const orderedBytes = applyByteOrder([bytes[i], bytes[i + 1], bytes[i + 2], bytes[i + 3]], byteOrder, 4);
                            const value = orderedBytes[0] | (orderedBytes[1] << 8) | (orderedBytes[2] << 16) | (orderedBytes[3] << 24);
                            result.push(dataType === 'int' && value > 2147483647 ? value - 4294967296 : value >>> 0);
                        }
                        break;
                        
                    case 'long':
                    case 'ulong':
                        for (let i = 0; i < bytes.length - 7; i += 8) {
                            const orderedBytes = applyByteOrder(bytes.slice(i, i + 8), byteOrder, 8);
                            let value = BigInt(0);
                            for (let j = 0; j < 8; j++) {
                                value |= BigInt(orderedBytes[j]) << BigInt(j * 8);
                            }
                            result.push(Number(value));
                        }
                        break;
                        
                    case 'float':
                        for (let i = 0; i < bytes.length - 3; i += 4) {
                            const orderedBytes = applyByteOrder([bytes[i], bytes[i + 1], bytes[i + 2], bytes[i + 3]], byteOrder, 4);
                            const buffer = new ArrayBuffer(4);
                            const view = new DataView(buffer);
                            for (let j = 0; j < 4; j++) {
                                view.setUint8(j, orderedBytes[j]);
                            }
                            const floatValue = view.getFloat32(0, true);
                            result.push(floatValue);
                        }
                        break;
                        
                    case 'double':
                        for (let i = 0; i < bytes.length - 7; i += 8) {
                            const orderedBytes = applyByteOrder(bytes.slice(i, i + 8), byteOrder, 8);
                            const buffer = new ArrayBuffer(8);
                            const view = new DataView(buffer);
                            for (let j = 0; j < 8; j++) {
                                view.setUint8(j, orderedBytes[j]);
                            }
                            const doubleValue = view.getFloat64(0, true);
                            result.push(doubleValue);
                        }
                        break;
                        
                    case 'ascii':
                        const asciiString = bytes.map(byte => 
                            byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : 'Â·'
                        ).join('');
                        result.push(asciiString);
                        break;
                }
                
                const displayValue = formatDisplayValue(result, dataType);
                const isValid = validateResult(result, dataType);
                
                return {
                    success: true,
                    data: result,
                    displayValue: displayValue,
                    isValid: isValid
                };
                
            } catch (error) {
                return { success: false, error: error.message };
            }
        }
        
        function applyByteOrder(bytes, byteOrder, expectedLength) {
            const paddedBytes = [...bytes];
            while (paddedBytes.length < expectedLength) {
                paddedBytes.push(0);
            }
            
            switch (byteOrder) {
                case 'ABCD':
                    return paddedBytes.reverse();
                case 'DCBA':
                    return paddedBytes;
                case 'CDAB':
                    if (expectedLength === 4) {
                        return [paddedBytes[2], paddedBytes[3], paddedBytes[0], paddedBytes[1]];
                    } else if (expectedLength === 2) {
                        return [paddedBytes[1], paddedBytes[0]];
                    } else if (expectedLength === 8) {
                        return [paddedBytes[6], paddedBytes[7], paddedBytes[4], paddedBytes[5], paddedBytes[2], paddedBytes[3], paddedBytes[0], paddedBytes[1]];
                    }
                    return paddedBytes;
                case 'BADC':
                    if (expectedLength === 4) {
                        return [paddedBytes[1], paddedBytes[0], paddedBytes[3], paddedBytes[2]];
                    } else if (expectedLength === 2) {
                        return [paddedBytes[1], paddedBytes[0]];
                    } else if (expectedLength === 8) {
                        return [paddedBytes[1], paddedBytes[0], paddedBytes[3], paddedBytes[2], paddedBytes[5], paddedBytes[4], paddedBytes[7], paddedBytes[6]];
                    }
                    return paddedBytes;
                default:
                    return paddedBytes;
            }
        }
        
        function formatDisplayValue(result, dataType) {
            if (result.length === 0) return '';
            
            switch (dataType) {
                case 'float':
                case 'double':
                    return result.map(v => {
                        if (isNaN(v) || !isFinite(v)) {
                            return v.toString();
                        }
                        return parseFloat(v.toFixed(6));
                    }).join(', ');
                case 'bool':
                    return result.slice(0, 32).map(v => v ? '1' : '0').join('');
                case 'ascii':
                    return result[0];
                default:
                    return result.join(', ');
            }
        }
        
        function validateResult(result, dataType) {
            if (result.length === 0) return false;
            
            switch (dataType) {
                case 'float':
                case 'double':
                    return result.some(v => isFinite(v) && !isNaN(v) && Math.abs(v) < 1e10);
                case 'ascii':
                    return /[a-zA-Z0-9]/.test(result[0]);
                default:
                    return true;
            }
        }
        
        function displayRawData() {
            const rawDataDisplay = document.getElementById('rawDataDisplay');
            const bytes = convertToBytes(currentData, currentInputFormat);
            
            rawDataDisplay.innerHTML = `
                <div class="process-step">
                    <div class="step-title">ğŸ“¥ è¾“å…¥æ•°æ® (${currentInputFormat})</div>
                    <div class="step-content">[${currentData.join(', ')}]</div>
                </div>
                <div class="process-step">
                    <div class="step-title">ğŸ”¢ è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„</div>
                    <div class="step-content">[${bytes.join(', ')}]</div>
                </div>
                <div class="process-step">
                    <div class="step-title">ğŸ”¤ åå…­è¿›åˆ¶è¡¨ç¤º</div>
                    <div class="step-content">[${bytes.map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase()).join(', ')}]</div>
                </div>
                <div class="process-step">
                    <div class="step-title">ğŸ’¾ äºŒè¿›åˆ¶è¡¨ç¤º</div>
                    <div class="step-content">[${bytes.map(b => '0b' + b.toString(2).padStart(8, '0')).join(', ')}]</div>
                </div>
            `;
        }
        
        function copyResult(text) {
            navigator.clipboard.writeText(text).then(() => {
                console.log('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
            });
        }
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
        
        // ç¨‹åºåŒ–åˆ‡æ¢æ ‡ç­¾ï¼ˆä¸ä¾èµ–eventå¯¹è±¡ï¼‰
        function switchTabProgrammatically(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // æ ¹æ®æ ‡ç­¾åæ‰¾åˆ°å¯¹åº”çš„æŒ‰é’®å¹¶æ¿€æ´»
            const tabMapping = {
                'smart-results': 0,
                'all-results': 1,
                'raw-data': 2
            };
            
            const buttons = document.querySelectorAll('.tab-btn');
            const targetIndex = tabMapping[tabName];
            if (targetIndex !== undefined && buttons[targetIndex]) {
                buttons[targetIndex].classList.add('active');
            }
            
            document.getElementById(tabName).classList.add('active');
        }
        
        // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
        function clearPreviousResults() {
            allResults = [];
            document.getElementById('allResultsGrid').innerHTML = '';
            document.getElementById('smartResultsGrid').innerHTML = '';
            document.getElementById('rawDataDisplay').innerHTML = '';
            document.getElementById('statisticsPanel').style.display = 'none';
            updateResultCounter(null); // éšè—è®¡æ•°å™¨
        }
        
        function clearInput() {
            document.getElementById('rawData').value = '';
            document.getElementById('inputValidation').innerHTML = '';
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('smartDetection').style.display = 'none';
            document.getElementById('recommendationPanel').style.display = 'none';
            document.getElementById('autoSelectNotice').style.display = 'none';
            
            // æ¸…ç©ºæ‰€æœ‰ç›¸å…³æ•°æ®å’Œç»“æœ
            currentData = [];
            smartAnalysisResults = {};
            recommendedConfigs = [];
            clearPreviousResults();
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('rawData').value = '[13312,0,16128,0,13312,0,8704,0,5888,0]';
        });
    </script>
</body>
</html>